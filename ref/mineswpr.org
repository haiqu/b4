#+title: mineswpr : minesweeper for retro
#+author: michal j wallace
#+date: 03 feb 2013

* language tweaks
#+name: lang-tweaks
#+begin_src retro

  ( -- language tweaks --------------------------------------- )

  : ≥ >= ; "( xy-? ) tests for x ≥ y . same as >=" :doc
  : ≤ <= ; "( xy-? ) tests for x ≤ y . same as <=" :doc
  : ≠ != ; "( xy-f ) just a fancy way to say !=" :doc
  : dec ( a- ) -- ;
  : inc ( a- ) ++ ;
  : shl << ;
  : shr >> ;
  : vars| ` variables| ;
  : dup2 ( xy-xyxy ) over over ;
  : recurse (  -  ) @last @d->xt , ; compile-only ( from forth.rx )
  with math'
    : randint ( n-n ) random swap mod ;
  without

  ( -- debug tools ------------------------------------------- )
  with| vt' ng' |
  {{
    : .? push |M .s |m pop puts |w ;
  ---reveal---
    : !! |r '! putc .s ;
    : ?? last @ d->name lit,, ` .? ; immediate
      "debug tool. at runtime, this will show the stack plus the name of the word in which it was used." :doc
  }}
  2without

  ( -- imperative flow control ------------------------------- )
  with ng'
  : ;c  ` ?? ` ; ` immediate ; immediate
  : come-from here swap ! ;
  : .ifso ahead ;c
    "c:  -a  | r:  f-   like IF in forth" :doc
  : .else ahead push come-from pop ;c
    "c:  a-a | r:   -   forth-style ELSE" :doc
  : .then   come-from ;c          "c:  a-  | r:   -   like THEN in forth" :doc
  : .repeat here ;c
  : .while  here ;c
  : .do     0 lit,, 0 =jump,, here 1- ;c
  : .again
      push       ( push the location of the jump from .do  )
        jump,,   ( compile a jump to the position marked by .while )
      pop come-from ;c
  : .until 0 lit,, =jump,, ;c
    "compile the UNTIL part of a repeat loop" :doc
  without
#+end_src

* the game
** DONE variables
#+name: variables
#+begin_src retro

  ( -- variables --------------------------------------------- )
  with sets'
    enum| «safe» «dead» |
    enum| ·mine ·cover ·flag ·hint |
    vars| gameOver? minefield flagCount |
  without

#+end_src

** DONE grid-type
#+name: grid-type
#+begin_src retro
  with sets'
    16 constant W
    16 constant H
    32 constant mineCount
    create grid W H * allot

    : cell ( xy-a ) W * + grid + ;
      "( xy-a ) given coordinates, return the address of the cell" :doc

    : inbounds?  0 H 1- within  0 W 1- within  and ;
      "( xy-f ) is the point somewhere inside the minefield?" :doc

    : randcell W randint H randint cell ;
      "( -a ) return a cell from the grid, at random" :doc

    ( cell methods )
    : has? swap @ swap in? ;
      "( ce- ) does cell c contain the element e?" :doc

    ( grid methods )
    : .fill swap W H * fill ;
      "( gx- ) fill grid g with value x" :doc

    : mine-add
      randcell dup ·mine has?
        [ drop mine-add ]
        [ ·mine @incl! ] if ;
      "( - ) add a mine to a random cell that doesn't yet have one" :doc

    : game-new
      gameOver? off
      ·cover as-bit grid .fill
      mineCount
        [ flagCount ! ]
        [ [ mine-add ] times ]
      bi ;
      "( - ) set up a new game" :doc

  without
#+end_src

** TODO floodfill { need xy-fill! }
#+name: floodfill
#+begin_src retro

  : xy-fill?
    dup2
      inbounds?
      cell [ ·cover has? not ]
           [ ·hint has? ] bi
           or
      and ;
    "( xy-f ) should the floodfill routine visit this cell?" :doc

  : xy-fill!
    ;
    "( xy- ) actally fill the cell" :doc

  : flood
    dup2 xy-fill?
    [ dup2 xy-fill!
      dup2 1- flood      ( north )
      dup2 1+ flood      ( south )
      swap
      dup2 1+ swap flood ( east )
           1- swap flood ( west )
    ] ifTrue ;
    "( xy-f ) runs the floodfill algorithm on the grid at the given coordinates" :doc

#+end_src

** DONE user actions
#+name: user-actions
#+begin_src retro
with sets'
  ( -- user actions ---------------------------------------------- )

  : flag+    ·flag @incl! ;
    "( a- ) place a flag on the cell" :doc

  : flag- ·flag @excl! ;
    "( a- ) remove the flag from the cell, if present" :doc

  : prod
    ·mine has?
    [ [ gameOver? ! ]
      [ [ «dead» ]
        [ «safe» ] if ] ] bi ;
    "( a-m ) prod the cell for a mine, and see what happens... :)" :doc

  : mineswpr-exit-hook ( revectored ) ;

without
#+end_src

** DONE draw the playing field
#+name: draw-field
#+begin_src retro
with vt'
   ( -- display words -------------------------------------------- )

   : . putc ; : $ puts ;
   : draw
     clear   |Y
    "                            MINESWPR.RXE" $
    |K .s |g cr
    |b "---------------------------------------------------------------------" $ |w cr
    "     0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F  " $ cr
    "   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+" $ cr
    " 0 |                                                               |" $ cr
    " 1 |                                                               |" $ cr
    " 2 |                                                               |" $ cr
    " 3 |                                                               |" $ cr
    " 4 |                                                               |" $ cr
    " 5 |                                                               |" $ cr
    " 6 |                                                               |" $ cr
    " 7 |                                                               |" $ cr
    " 8 |                                                               |" $ cr
    " 9 |                                                               |" $ cr
    " A |                                                               |" $ cr
    " B |                                                               |" $ cr
    " C |                                                               |" $ cr
    " D |                                                               |" $ cr
    " E |                                                               |" $ cr
    " F |                                                               |" $ cr
    "   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+" $ cr
    |g
    "type cmd at " $ '" . |w "ok" $ |g '" . ":  " $
      |Y '+ . |c " = flag  " $
      |Y '- . |c " = unflag  " $
      |Y '? . |c " = prod for mine " $
      |Y 'q . |c " = quit" $
    cr
    |g "cmd format: " $  |Y "x y " $ '[ |c . |Y "+-?" $ |c '] . |c "   " $
    |g "examples: " $ |w "5 C +" $ |y " a b -" $  |W " 2 9 ?" $ |R " q" $ cr
    |b "---------------------------------------------------------------------" $ cr
    |W "ok " $ |w ;
 "draw the mineswpr ui / prompt" :doc
without
#+end_src

** TODO draw the cells
#+name: draw-cells
#+begin_src retro
  with| vt' ng' |

    : (x,y) |c '( putc |g swap putn |c ", " |g puts putn  |c ') putc |w ;
      "( xy- ) output coordinate pair as a string" :doc

    variables| ii jj |
    : rows cr 0 jj !
      .repeat
        jj [ W ii ! |c @ putn space |w
             .while ii @ 0 > .do
               ii [ -- ] 
                  [ @ $F swap - jj @ 
                    hex space 2putn ] bi
             .again cr ]
           [ ++ ] 
           [ @ H ≥ ] tri
      .until ;

  2without
#+end_src

** DONE command parser
#+name: cmd-parser
#+begin_src retro
hex
chain: mswp'
  ( ui command syntax )
  : + cell flag+ ;
  : - cell flag- ;
  : ? cell prod  ;
  : a A ;
  : b B ;
  : c C ;
  : d D ;
  : e E ;
  : f F ;
  : q mineswpr-exit-hook ;
   "minesweeper parser" :doc
;chain
decimal
#+end_src
** DONE retro shell enhancements
#+name: shell-tweaks
#+begin_src retro
( -- retro shell enhancements ------------------------------ )
with vt' with color'
: welcome
  clear
  |W "Welcome to Retro!" $ cr
  |w "Type " $ |Y "words " $
  |w "to see a list of words you can try, or " $
  |Y "play " $ |w "to play the game again." $ |w cr ;
  "a rudimentary welcome message." :doc
{{
  : mineswpr-play
    &draw &ok :is
    reset hex
    game-new
    "mswp'" find [ d->xt @ :with ] ifTrue ;

  : mineswpr-quit
    without
    reset decimal
    &grok &ok :is
    welcome ;

  &mineswpr-quit &mineswpr-exit-hook :is
---reveal---

  : play mineswpr-play ;
    "( - ) play minesweeper" :doc
}}
2without
#+end_src

* OUTPUT
#+begin_src retro  :tangle "~/b/rx/mineswpr.rx" :padline yes :noweb tangle
needs sets' needs vt'  needs math'
<<lang-tweaks>>

( == minesweeper game ====================================== )

<<variables>>
<<grid-type>>
<<floodfill>>
<<user-actions>>
<<draw-field>>
<<draw-cells>>
<<cmd-parser>>
<<shell-tweaks>>

( play )

#+end_src

* TODO refile these
** objects
: method push ;
: self pop dup push ;
: end pop drop ;

** trash words
#+begin_src retro
#+end_src

** virtual terminal words
#+begin_src retro
chain: vt'

 |!k 0 vt:bg ; : |!r 1 vt:bg ; : |!g 2 vt:bg ; : |!y 3 vt:bg ;
 |!b 4 vt:bg ; : |!m 5 vt:bg ; : |!c 6 vt:bg ; : |!w 7 vt:bg ;

#+end_src
* debug words
