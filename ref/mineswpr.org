#+title: mineswpr : minesweeper for retro
#+author: michal j wallace
#+date: 03 feb 2013

* language tweaks
** misc
#+name: lang-tweaks
#+begin_src retro

  ( -- language tweaks --------------------------------------- )

  : ≥ >= ; "( xy-? ) tests for x ≥ y . same as >=" :doc
  : ≤ <= ; "( xy-? ) tests for x ≤ y . same as <=" :doc
  : ≠ != ; "( xy-f ) just a fancy way to say !=" :doc
  : dec ( a- ) -- ;
  : inc ( a- ) ++ ;
  : shl << ;
  : shr >> ;
  : odd 1 and 0 != ;
  : vars| ` variables| ;
  : dup2 ( xy-xyxy ) over over ;
  : recurse (  -  ) @last @d->xt , ; compile-only ( from forth.rx )
  : spaces [ space ] times ; "( n- ) emit n spaces" :doc
  : deep push over pop swap ;
    "( xyz-xyzx ) copies the 3rd item to the top of the stack. ( dup, over, deep... )" :doc
  : cop pop dup push ;
    "( -n ) copies a value from the return stack" :doc
  with math'
    : randint ( n-n ) random swap mod ;
  without
#+end_src
** debug tools
#+name: lang-tweaks
#+begin_src retro
  ( -- debug tools ------------------------------------------- )
  with| vt' ng' |
  {{
    : .? decimal push |y .s pop |Y puts |w ;
    variable depth
    : indent 2 * spaces ;
    : [context] last @ d->name lit,, ;
    : { cr depth dup ++ @ indent |M puts space '{ putc |w ;
    : } cr depth dup @ indent -- |M '} putc space puts |w ;
  ---reveal---
    : !! |R .s |r "!!" puts ;
    : ?{ [context] ` { ; immediate
    : }? [context] ` } ; immediate
    : ?? depth @ spaces [context] ` .? ; immediate
      "debug tool. at runtime, this will show the stack plus the name of the word in which it was used." :doc
  }}
  2without
#+end_src
** imperative macros
#+name: lang-tweaks
#+begin_src retro
  ( -- imperative flow control ------------------------------- )
  with ng'
  : ;c  ` ?? ` ; ` immediate ; immediate
  {{ ( these two should *not* be immediate. they're called by immediates )
    : .come-from here swap ! ;
    : .else-ahead 0 lit,, 0 =jump,, here 1- ;
  ---reveal---
  : .ifso .else-ahead  ;c                "c:  -a  | r:  f-   like IF in forth" :doc
  : .else ahead push .come-from pop ;c   "c:  a-a | r:   -   forth-style ELSE" :doc
  : .then   .come-from ;c                "c:  a-  | r:   -   like THEN in forth" :doc
  : .repeat here ;c
  : .while  here ;c
  : .do  .else-ahead ;c
  : .again
      push       ( push the location of the jump from .do  )
        jump,,   ( compile a jump to the position marked by .while )
      pop .come-from ;c
  : .until 0 lit,, =jump,, ;c           "compile the UNTIL part of a repeat loop" :doc
  }}
  without
#+end_src

* the game
** DONE variables
#+name: variables
#+begin_src retro

  ( -- variables --------------------------------------------- )

  enum| ·mine ·cover ·flag |
  vars| gameOver? minefield flagCount |
  variable allHints?  ( debug flag )

#+end_src

** DONE grid-setup
#+name: grid-setup
#+begin_src retro
  16 constant W
  16 constant H
  32 constant mineCount
  create grid W H * allot

  : grid-size W H * ;
#+end_src

** DONE point-methods
#+name: point-methods
#+begin_src retro
  ( point2d methods )
  : nn 1- ; "( xy-xy ) north" :doc
  : ss 1+ ; "( xy-xy ) south" :doc
  : ee swap 1+ swap ; "( xy-xy ) east" :doc
  : ww swap 1- swap ; "( xy-xy ) west" :doc
  : ne nn ee ; "( xy-xy ) north-east" :doc
  : se ss ee ; "( xy-xy ) south-east" :doc
  : sw ss ww ; "( xy-xy ) south-west" :doc
  : nw nn ww ; "( xy-xy ) north-west" :doc
  {{
    3 elements x y q
    : xy x @ y @ ;
    : qq q @ do ;
  ---reveal---

    : cardinal-neighbors-do q ! y ! x !
                  xy nn qq
      xy ww qq     ( xy )     xy ee qq
                  xy ss qq ;
     "( xyq- ) invoke q { xy-?? } for points to n,w,e,s" :doc

     : ordinal-neighbors-do q ! y ! x !
      xy nw qq                xy ne qq
                   ( xy )
      xy sw qq                xy se qq ;
     "( xyq- ) invoke q { xy-?? } for points to nw,ne,sw,se" :doc

     : neighbors-do q ! y ! x !
      xy nw qq    xy nn qq    xy ne qq
      xy ww qq     ( xy )     xy ee qq
      xy sw qq    xy ss qq    xy se qq ;
     "( xyq- ) invoke q { xy-?? } for all eight neighboring points" :doc

  }}

  : cell ( xy-a ) W * + grid + ;
    "( xy-a ) given coordinates, return the address of the cell" :doc

  : inbounds? 0 H 1- within .ifso 0 W 1- within .else drop ( W- ) 0 .then ;
    "( xy-f ) is the point somewhere inside the minefield?" :doc

#+end_src

** DONE cell methods
#+name: cell-methods
#+begin_src retro
    ( cell methods )
    : has? swap @ swap in? ;
      "( ce- ) does cell c contain the element e?" :doc

    : uncover ·cover @excl! ;
      "( c- ) remove the cover from cell c" :doc

    : armed-neighbor-count @ 8 shr ;
      "( c-n )  number of armed neighbors ( 0..8 )" :doc

    : armed-neighbor-add $100 swap +! ;
      "( c- )  increment count of armed neighbors ( 0..8 )" :doc

    : c>xy  grid - W /mod ;
      "( c-xy ) given a cell, return its xy coordinates." :doc

    : randcell W randint H randint cell ;
      "( -a ) return a cell from the grid, at random" :doc
#+end_src

** DONE grid methods
#+name: grid-methods
#+begin_src retro
    ( grid methods )
    : .fill swap W H * fill ;
      "( gx- ) fill grid g with value x" :doc

    : grid-do grid-size [ 1- grid + over do ] iterd drop ;
      "( q- ) for each cell in the grid, put the cell's address in tos and run q." :doc
#+end_src
** DONE floodfill
#+name: floodfill
#+begin_src retro

  : needs-visit?                 ( visit cells that are ... )
    dup c>xy inbounds?           (  - within bounds )
      .ifso ·cover has?          (  - and still covered )
      .else drop 0
    .then ;
    "( c-f ) should we call xy-fill! on this cell?" :doc

  : neighborhood-safe? armed-neighbor-count 0 = ; "( c-f )" :doc

  : visit dup uncover ;
    "( c-f ) actually fill the cell." :doc
  : keep-going? neighborhood-safe? ;
  : flood-step-hook ; "( - )  just a hook for debugging " :doc

  : flood cell                     ( xy-c  )
    dup needs-visit?               (  c-cf )
      .ifso                        ( cf-c  )
         dup visit
             flood-step-hook
         dup keep-going?
           .ifso c>xy [ flood ] cardinal-neighbors-do
           .else drop
         .then
      .else drop
    .then ;
    "( xy- ) runs the floodfill algorithm on the grid at the given cell" :doc

#+end_src

** DONE event handlers
#+name: events
#+begin_src retro
  ( -- event handlers ---------------------------------------------- )

    : «dead»
         gameOver? -1 !
         "game over. press any key" puts getc
         [ uncover ] grid-do ;
      "( a- ) called after detonating cell a" :doc

    : «safe» c>xy flood ;
      "( a- ) called after prodding cell a with no mine" :doc

    : mineswpr-exit-hook ( revectored ) ;

#+end_src

** DONE user actions
#+name: user-actions
#+begin_src retro

    ( -- user actions ---------------------------------------------- )
    : flaggable? dup ·flag has? .ifso drop 0 .else ·cover has? .then ;
      "( a-f ) possible to put a flag on this cell?" :doc

    : flag+ dup flaggable? [ ·flag @incl! flagCount ++ ] [ drop ] if ;
      "( a- ) place a flag on the cell" :doc

    : flag- ·flag dup2 ( cfcf ) has? [ @excl! flagCount -- ] [ 2drop ] if ;
      "( a- ) remove the flag from the cell, if present" :doc

    : prod
       dup [ flag- ] [ ·cover has? ] bi ( aa-af )
      .ifso ( af-a ) dup ·mine has? [ «dead» ] [ «safe» ] if
      .else drop
      .then ;
      "( a- ) prod the cell for a mine, and see what happens... :)" :doc
#+end_src

** DONE minefield words
#+name: minefield-words
#+begin_src retro

  ( -- minefield words --------------------------------------- )

  : hints-create
    [ dup ·mine has?
        .ifso
          c>xy
          [ dup2 inbounds?
              .ifso cell armed-neighbor-add
              .else drop drop
            .then
          ] neighbors-do
        .else drop
      .then
    ] grid-do ;
    "( - ) generate the armed-neighbor-count for each cell on the grid" :doc

  : mine-add
    randcell
    dup ·mine has?
      .ifso drop recurse
      .else ·mine @incl!
    .then ;
    "( - ) add a mine to a random cell that doesn't yet have one" :doc

  : game-new
    ·cover as-bit grid .fill
    mineCount [ mine-add ] times
    hints-create
    0 flagCount !
    gameOver? off ;
    "( - ) set up a new game" :doc

#+end_src

** DONE draw the cells
#+name: draw-cells
#+begin_src retro
  with vt' with ng'

    : |? ;

    : in-brackets |? '[ putc do putc |? '] putc ;
    : no-brackets      space do putc      space ;

    : hint armed-neighbor-count ;

    : mine-draw  drop                 'X   &|r               no-brackets ;
    : flag-draw  drop                 '!   &|R dup &|? ` :is in-brackets ;
    : hint-draw 
      hint dup 0 =
      .ifso      drop                 '-   &|b               no-brackets
      .else                           '0 + &|B               in-brackets
      .then ;
    : cover-draw
      allHints? @
        .ifso    hint-draw
        .else    drop                 '-   &|w               in-brackets
      .then ;

    : (x,y)

      ( horizontal stripes: )
      dup odd [ [ |K ] ] [ [ |c ] ] if &|? ` :is

      cell dup @
      [ [ ·mine in? gameOver? @ and ]   [ mine-draw  ] whend
        [ ·flag  in? ]                  [ flag-draw  ] whend
        [ ·cover in? ]                  [ cover-draw ] whend
        [ drop   -1  ]                  [ hint-draw  ] whend ] do
     space ;
     "( xy- ) output cell as a string" :doc

    : show cr
      H [ dup 2 spaces hex dup odd [ |w ] [ |C ] if putn space
            W [ over (x,y) ] iter cr drop ] iter ;
      "draw the minefield" :doc

  2without
#+end_src

** DONE draw the playing field
#+name: draw-field
#+begin_src retro
with vt'
   ( -- display words -------------------------------------------- )

   : . putc ; : $ puts ;
   : draw clear
    |Y "                            MINESWPR.RXE" $
    |g cr
    |b "---------------------------------------------------------------------" $ |w cr
    |C "     0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F   " $
    show
    |g cr
    "type cmd at " $ '" . |w "ok" $ |g '" . ":  " $
      |Y '+ . |c " = flag  " $
      |Y '- . |c " = unflag  " $
      |Y '? . |c " = prod for mine " $
      |Y 'q . |c " = quit" $
    cr
    |g "cmd format: " $  |Y "x y " $ '[ |c . |Y "+-?" $ |c '] . |c "   " $
    |g "examples: " $ |w "5 C +" $ |y " a b -" $  |W " 2 9 ?" $ |R " q" $
                                           |Y   "   r " $ |c "= restart " $ cr
    |b "---------------------------------------------------------------------" $
    |K .s cr
    |W "ok " $ |w ;
 "draw the mineswpr ui / prompt" :doc
without
#+end_src

** DONE command parser
#+name: cmd-parser
#+begin_src retro
hex
chain: mswp'
  ( ui command syntax )
  : + depth 2 >= [ cell flag+ ] ifTrue ;
  : - depth 2 >= [ cell flag- ] ifTrue ;
  : ? depth 2 >= [ cell prod ]  ifTrue ;
  : a A ;
  : b B ;
  : c C ;
  : d D ;
  : e E ;
  : f F ;
  : r game-new ;
  : q mineswpr-exit-hook ;
   "minesweeper parser" :doc
;chain
decimal
#+end_src
** DONE retro shell enhancements
#+name: shell-tweaks
#+begin_src retro
( -- retro shell enhancements ------------------------------ )
with vt' with color'
: welcome
  clear
  |W "Welcome to Retro!" $ cr
  |w "Type " $ |Y "words " $
  |w "to see a list of words you can try, or " $
  |Y "play " $ |w "to play the game again." $ |w cr ;
  "a rudimentary welcome message." :doc
{{
  : mineswpr-play
    &draw &ok :is
    reset hex
    game-new
    "mswp'" find [ d->xt @ :with ] ifTrue ;

  : mineswpr-quit
    without
    reset decimal
    &grok &ok :is
    welcome ;

  &mineswpr-quit &mineswpr-exit-hook :is
---reveal---

  : play mineswpr-play ;
    "( - ) play minesweeper" :doc
}}
2without
#+end_src

* OUTPUT
#+begin_src retro  :tangle "~/b/rx/mineswpr.rx" :padline yes :noweb tangle
needs sets' needs vt'  needs math'
<<lang-tweaks>>

( == minesweeper game ====================================== )
with sets'
<<variables>>
<<grid-setup>>
<<point-methods>>
<<cell-methods>>
<<grid-methods>>
<<floodfill>>
<<events>>
<<user-actions>>
<<minefield-words>>
<<draw-cells>>
<<draw-field>>
<<cmd-parser>>
<<shell-tweaks>>

game-new

0 ( debug hook )
.ifso [ clear show getc 'q = .ifso bye .then ] &flood-step-hook :is .then

play

#+end_src

* TODO refile these
** objects
: method push ;
: self pop dup push ;
: end pop drop ;

** trash words
#+begin_src retro
#+end_src

** virtual terminal words
#+begin_src retro
chain: vt'

 |!k 0 vt:bg ; : |!r 1 vt:bg ; : |!g 2 vt:bg ; : |!y 3 vt:bg ;
 |!b 4 vt:bg ; : |!m 5 vt:bg ; : |!c 6 vt:bg ; : |!w 7 vt:bg ;

#+end_src

    : (x,y) |c '( putc |g swap putn |c ", " |g puts putn  |c ') putc |w ;
      "( xy- ) output coordinate pair as a string" :doc


* debug words
