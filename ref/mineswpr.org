#+title: mineswpr : minesweeper for retro
#+author: michal j wallace
#+date: 03 feb 2013

* language tweaks
#+name: lang-tweaks
#+begin_src retro

  ( -- language tweaks --------------------------------------- )

  : ≥ >= ; "( xy-? ) tests for x ≥ y . same as >=" :doc
  : ≤ <= ; "( xy-? ) tests for x ≤ y . same as <=" :doc
  : ≠ != ; "( xy-f ) just a fancy way to say !=" :doc
  : dec ( a- ) -- ;
  : inc ( a- ) ++ ;
  : shl << ;
  : shr >> ;
  : odd 1 and 0 != ;
  : vars| ` variables| ;
  : dup2 ( xy-xyxy ) over over ;
  : recurse (  -  ) @last @d->xt , ; compile-only ( from forth.rx )
  : spaces [ space ] times ; "( n- ) emit n spaces" :doc
  : deep push over pop swap ;
    "( xyz-xyzx ) copies the 3rd item to the top of the stack. ( dup, over, deep... )" :doc
  with math'
    : randint ( n-n ) random swap mod ;
  without

  ( -- debug tools ------------------------------------------- )
  with| vt' ng' |
  {{
    : .? push |y .s pop |Y puts |w ;
    variable depth
    : indent 2 * spaces ;
    : [context] last @ d->name lit,, ;
    : { cr depth dup ++ @ indent |M puts space '{ putc |w ;
    : } cr depth dup @ indent -- |M '} putc space puts |w ;
  ---reveal---
    : !! |R .s |r "!!" puts ;
    : ?{ [context] ` { ; immediate
    : }? [context] ` } ; immediate
    : ?? depth @ spaces [context] ` .? ; immediate
      "debug tool. at runtime, this will show the stack plus the name of the word in which it was used." :doc
  }}
  2without

  ( -- imperative flow control ------------------------------- )
  with ng'
  : ;c  ` ?? ` ; ` immediate ; immediate
  {{ ( these two should *not* be immediate. they're called by immediates )
    : .come-from here swap ! ;
    : .else-ahead 0 lit,, 0 =jump,, here 1- ;
  ---reveal---
  : .ifso .else-ahead  ;c                "c:  -a  | r:  f-   like IF in forth" :doc
  : .else ahead push .come-from pop ;c   "c:  a-a | r:   -   forth-style ELSE" :doc
  : .then   .come-from ;c                "c:  a-  | r:   -   like THEN in forth" :doc
  : .repeat here ;c
  : .while  here ;c
  : .do  .else-ahead ;c
  : .again
      push       ( push the location of the jump from .do  )
        jump,,   ( compile a jump to the position marked by .while )
      pop .come-from ;c
  : .until 0 lit,, =jump,, ;c           "compile the UNTIL part of a repeat loop" :doc
  }}
  without
#+end_src

* the game
** DONE variables
#+name: variables
#+begin_src retro

  ( -- variables --------------------------------------------- )
  with sets'
    enum| ·mine ·cover ·flag ·hint |
    vars| gameOver? minefield flagCount |
  without

#+end_src

** DONE grid-type
#+name: grid-type
#+begin_src retro
  with sets'
    16 constant W
    16 constant H
    32 constant mineCount
    create grid W H * allot
  
    : grid-size W H * ;
  
    : cell ( xy-a ) W * + grid + ;
      "( xy-a ) given coordinates, return the address of the cell" :doc
  
    : c>xy  grid - W /mod ;
      "( xy-a ) given a cell, return its xy coordinates." :doc
  
    : inbounds?  0 H 1- within .ifso 0 W 1- within .else 0 .then ;
      "( xy-f ) is the point somewhere inside the minefield?" :doc
  
    : randcell W randint H randint cell ;
      "( -a ) return a cell from the grid, at random" :doc
  
    ( cell methods )
    : has? swap @ swap in? ;
      "( ce- ) does cell c contain the element e?" :doc
    : uncover ·cover @excl! ;
      "( c- ) remove the cover from cell c" :doc
    : armed-neighbor-count 1 ;
      "( c- ) remove the cover from cell c" :doc

    ( grid methods )
    : .fill swap W H * fill ;
      "( gx- ) fill grid g with value x" :doc
  
    : mine-add
      randcell dup ·mine has?
        [ drop mine-add ] [ ·mine ?? @incl! ] if ?? ;
      "( - ) add a mine to a random cell that doesn't yet have one" :doc
  
    (  todo: see if i can tie this in with each@ )
    : grid-do grid swap grid-size ??
      [ ( qgi ) over + ( qga ) deep ( qgaq ) do ] iter ;
      "( q- ) for each cell in the grid, push the cell's address, and run q." :doc
  
  without
#+end_src

** DONE floodfill
#+name: floodfill
#+begin_src retro
with sets'

  : xy-fill? ?{ dup2 inbounds? ??
    .ifso ( visit cells that are still covered but do not already have hints )
       cell [ ·cover has? ] [ ·hint has? not ] bi and
    .else 2drop 0 .then }? ;
    "( xy-f ) should we call xy-fill! on this cell?" :doc
   
  : xy-fill! ( we already know there is a cover and no hint, thanks to 'xy-fill?' )
    cell dup armed-neighbor-count 0 = [ uncover ] [ ·hint @incl! ] if ;
    "( xy- ) actually fill the cell." :doc

  : flood ?{
    dup2 xy-fill?
    [ dup2 xy-fill!
      dup2 1- flood      ( north )
      dup2 1+ flood      ( south )
      swap
      dup2 1+ swap flood ( east )
           1- swap flood ( west )
    ] [ 2drop ] if }? ;
    "( xy-f ) runs the floodfill algorithm on the grid at the given coordinates" :doc

without
#+end_src


** DONE event handlers
#+name: events
#+begin_src retro
  ( -- event handlers ---------------------------------------------- )

    : «dead» gameOver? -1 ! [ uncover ] grid-do ?? ;
      "( a- ) called after detonating cell a" :doc

    : «safe» c>xy flood ;
      "( a- ) called after prodding cell a with no mine" :doc

    : mineswpr-exit-hook ( revectored ) ;

#+end_src

** DONE user actions
#+name: user-actions
#+begin_src retro
  with sets'
    ( -- user actions ---------------------------------------------- )
    : flaggable? ·flag has? .ifso 0 .else ·cover has? not .then ?? ;
      "( a-f ) possible to put a flag on this cell?" :doc

    : flag+ dup flaggable? [ ·flag @incl! flagCount ++ ] [ drop ] if ;
      "( a- ) place a flag on the cell" :doc
  
    : flag- ·flag dup2 ( cfcf ) has? [ @excl! flagCount -- ] [ drop ] if ;
      "( a- ) remove the flag from the cell, if present" :doc

    : prod ?{ dup flag- ·cover has?
      .ifso
         dup ·mine has? [ «dead» ] [ «safe» ] if
      .then }? ;
      "( a- ) prod the cell for a mine, and see what happens... :)" :doc

    : game-new
      gameOver? off 0 flagCount !
      ·cover as-bit grid .fill
      mineCount [ mine-add ] times ;
      "( - ) set up a new game" :doc
  
  without
#+end_src

** DONE draw the cells { still need to show all mines on game over }
#+name: draw-cells
#+begin_src retro
  with| vt' ng' sets' |
    : |? ;
    : (x,y) dup odd [ [ |K ] ] [ [ |c ] ] if &|? ` :is
      cell @
      [ [ ·flag  in? ]  [ '! &|R dup &|? ` :is -1 ] whend
        [ ·hint  in? ]  [ '8 &|B -1 ] whend
        [ ·cover in? ]  [ '- &|w -1 ] whend
        [ ·mine  in? ]  [ 'X &|r  0 ] whend
                          32 &|b  0   ] do
     [ |? '[ putc do putc |? '] putc ]
     [      space do putc space      ] if
     space ;
     "( xy- ) output cell as a string" :doc
    
    : show
      $10 [ dup 2 spaces hex dup odd [ |w ] [ |C ] if putn space
            $10 [ over (x,y) ] iter cr drop ]
      iter ;

  2without without
#+end_src

** DONE draw the playing field
#+name: draw-field
#+begin_src retro
with vt'
   ( -- display words -------------------------------------------- )

   : . putc ; : $ puts ;
   : draw ( clear )
    |Y "                            MINESWPR.RXE" $
    |g cr
    |b "---------------------------------------------------------------------" $ |w cr
    |C "     0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F   " $ cr
    show
    |g cr
    "type cmd at " $ '" . |w "ok" $ |g '" . ":  " $
      |Y '+ . |c " = flag  " $
      |Y '- . |c " = unflag  " $
      |Y '? . |c " = prod for mine " $
      |Y 'q . |c " = quit" $
    cr
    |g "cmd format: " $  |Y "x y " $ '[ |c . |Y "+-?" $ |c '] . |c "   " $
    |g "examples: " $ |w "5 C +" $ |y " a b -" $  |W " 2 9 ?" $ |R " q" $
                                           |Y   "   r " $ |c "= restart " $ cr
    |b "---------------------------------------------------------------------" $
    |K .s cr
    |W "ok " $ |w ;
 "draw the mineswpr ui / prompt" :doc
without
#+end_src



** DONE command parser
#+name: cmd-parser
#+begin_src retro
hex
chain: mswp'
  ( ui command syntax )
  : + depth 2 >= [ cell flag+ ] ifTrue ;
  : - depth 2 >= [ cell flag- ] ifTrue ;
  : ? depth 2 >= [ cell prod ]  ifTrue ;
  : a A ;
  : b B ;
  : c C ;
  : d D ;
  : e E ;
  : f F ;
  : r game-new ;
  : q mineswpr-exit-hook ;
   "minesweeper parser" :doc
;chain
decimal
#+end_src
** DONE retro shell enhancements
#+name: shell-tweaks
#+begin_src retro
( -- retro shell enhancements ------------------------------ )
with vt' with color'
: welcome
  clear
  |W "Welcome to Retro!" $ cr
  |w "Type " $ |Y "words " $
  |w "to see a list of words you can try, or " $
  |Y "play " $ |w "to play the game again." $ |w cr ;
  "a rudimentary welcome message." :doc
{{
  : mineswpr-play
    &draw &ok :is
    reset hex
    game-new
    "mswp'" find [ d->xt @ :with ] ifTrue ;

  : mineswpr-quit
    without
    reset decimal
    &grok &ok :is
    welcome ;

  &mineswpr-quit &mineswpr-exit-hook :is
---reveal---

  : play mineswpr-play ;
    "( - ) play minesweeper" :doc
}}
2without
#+end_src

* OUTPUT
#+begin_src retro  :tangle "~/b/rx/mineswpr.rx" :padline yes :noweb tangle
needs sets' needs vt'  needs math'
<<lang-tweaks>>

( == minesweeper game ====================================== )

<<variables>>
<<grid-type>>
<<floodfill>>
<<events>>
<<user-actions>>
<<draw-cells>>
<<draw-field>>
<<cmd-parser>>
<<shell-tweaks>>

game-new
play

#+end_src

* TODO refile these
** objects
: method push ;
: self pop dup push ;
: end pop drop ;

** trash words
#+begin_src retro
#+end_src

** virtual terminal words
#+begin_src retro
chain: vt'

 |!k 0 vt:bg ; : |!r 1 vt:bg ; : |!g 2 vt:bg ; : |!y 3 vt:bg ;
 |!b 4 vt:bg ; : |!m 5 vt:bg ; : |!c 6 vt:bg ; : |!w 7 vt:bg ;

#+end_src
    : (x,y) |c '( putc |g swap putn |c ", " |g puts putn  |c ') putc |w ;
      "( xy- ) output coordinate pair as a string" :doc


* debug words
