#+title: b+ trees
#+author: michal j wallace

* [0/2] overview
** TODO what is a b+ tree?
** TODO what problem does a b+ tree overcome?
* Object Model and Public Interface
** unit =bp=;
#+name: interface
#+begin_src pascal
  { B+ Trees for pascal }
  {$mode objfpc}
  unit bp;
  interface

    const empty = -maxint;

    type
      TKey   = integer;
      TVal   = TObject;
      IBPlus = interface
        <<IBPlusMethods>>
      end;
      <<TNode>>
      TTree  = class; // forward reference for TIter
      <<TIter>>
      <<TTree>>

#+end_src

** Public =IBPlus= interface

#+name: IBPlusMethods
#+begin_src pascal
  procedure put( key : TKey; val : TVal );
  //procedure del( key : TKey );
  //function get( key : TKey ): TVal;
  //function has( key : Tkey ): boolean;
#+end_src

** type =TNode=
#+name: TNode
#+begin_src pascal

  TNode = class ( TInterfacedObject, IBPlus )
   public
    constructor Create( size : integer = 32 );
    <<IBPlusMethods>>
   private
    isleaf      : boolean;
    _parent   : TNode;
    _next     : TNode;
    childkeys : array of TKey;
    childvals : array of TObject;
    function locate( key : TKey ): TNode;
    function inskey( key : TKey ): cardinal;
    function full : boolean;
    procedure split;
    procedure rebalance;
    function firstkey : TKey;
    function isroot : boolean;
    procedure addchild( key : TKey; kid : TNode );
    function next : TNode;
  end;

#+end_src

** type =TTree=
#+name: TTree
#+begin_src pascal
  TTree = class
   public
    constructor Create;
    <<IBPlusMethods>>
    function GetEnumerator: TIter;
   private
    root : TNode;
  end;
#+end_src

** type =TIter=
#+name: TIter
#+begin_src pascal
  TIter = class
  private
    tree : TTree; // only useful to support Reset
    node : TNode;
    step : integer;  // index/offset within the node
  public
    constructor Create( aTree : TTree );
    function GetCurrent : TVal;
    function MoveNext : Boolean;
    procedure Reset;
    property Current:TVal read GetCurrent;
  end;
#+end_src

* Implementation (roughly following [[http://en.wikipedia.org/wiki/B%2B_tree][wikipedia: B+ Trees]])
** TODO [0/0] Node class
*** DONE constructor
#+name: imp
#+begin_src pascal
  constructor TNode.Create( size : integer = 32 );
    var i : integer;
  begin
    isleaf := false;
    _next  := nil;
    _parent := nil;
    SetLength( childkeys, size );
    SetLength( childvals, size );
    for i := 0 to size-1 do
    begin
      childkeys[i] := empty;
      childvals[i] := nil;
    end;
  end;
#+end_src
*** DONE [1/1] location
**** DONE TNode.locate
#+name: imp
#+begin_src pascal

  { This search routine always succeeds, since it finds the location
    where the key /should/ be in the tree, whether it's /actually/
    there or not. }
  function TNode.locate( key : TKey ) : TNode;
    var i : integer = 0;
  begin
    if isleaf then result := self
    else begin
      { find first child key less the new key }
      while (key >= childkeys[ i ])
        and (i < length(childkeys))
        do inc( i );
      { have the child do what we just did }
        result := TNode(childvals[ i ]).locate( key );
    end
  end;

#+end_src

*** DONE [9/9] insertion
**** DONE TNode.put
#+name: imp
#+begin_src pascal
  procedure TNode.put( key : TKey; val : TVal );
  begin
    if isleaf then
      begin
        childvals[inskey( key )] := val;
        rebalance;
      end
    else locate( key ).put( key, val )
  end;
#+end_src

**** DONE TNode.inskey
#+name: imp
#+begin_src pascal
  { insert key }
  function TNode.inskey( key : TKey ) : cardinal;
   var i : integer;
  begin
    i := length(childvals);
    { find the first empty slot by scanning backward from the end: }
    while (i > 0) and (childkeys[i-1] = empty) do dec( i );

    { Make room for the key, keeping the sequence ordered. }
    { We needn't check for i>0 because childkeys[0] is always -maxint }
    while (childkeys[i-1] > key) do
      begin
        childvals[i] := childvals[i-1];
        childkeys[i] := childkeys[i-1];
        dec( i );
      end;

    { finally, fill the hole we just made, and return its location }
    childkeys[ i ] := key;
    childvals[ i ] := nil;
    result := i
  end;
#+end_src
**** DONE TNode.rebalance
#+name: imp
#+begin_src pascal
  procedure TNode.rebalance;
  begin
    if full then split
  end;
#+end_src

**** DONE TNode.full
#+name: imp
#+begin_src pascal
  function TNode.full : boolean;
  begin
    result := childkeys[high(childkeys)] <> empty;
  end;
#+end_src

**** DONE TNode.split
#+name: imp
#+begin_src pascal
  procedure TNode.split;
    var newnode: TNode;
    <<copyhalf>>
  begin
    newnode := TNode.create;
    newnode._next := _next;
    _next := newnode;
    copyhalf;
    childvals[high(childvals)] := newnode;
    if isroot then begin
      _parent := TNode.create;
      _parent.isleaf := false;
      _parent.addchild( self.firstkey, self )
    end;
    _parent.addchild( newnode.firstkey, newnode )
  end;
#+end_src
**** DONE <<copyhalf>>
#+name: copyhalf
#+begin_src pascal
  procedure copyhalf;
    var i, half : integer;
  begin
    half := length(childkeys) div 2;
    for i := half to high(childkeys) do
    begin
      newnode.childkeys[i-half] := childkeys[i];
      newnode.childvals[i-half] := childvals[i];
      childkeys[i] := empty;
      childvals[i] := nil;
    end
  end;
#+end_src

**** DONE TNode.isroot
#+name: imp
#+begin_src pascal
  function TNode.isroot : boolean;
  begin
    result := not assigned(_parent);
  end;
#+end_src

**** DONE firstkey
#+name: imp
#+begin_src pascal
  { The 0th key is always -maxint, so that we can have the same }
  { number of keys and values. This way there's no special case }
  { logic. This just lets us avoid hard coding the "[1]". }
  function TNode.firstkey : TKey;
  begin
    result := childkeys[1]
  end;
#+end_src

**** DONE addchild
#+name: imp
#+begin_src pascal
  procedure TNode.addchild( key : TKey; kid : TNode );
  begin
  end;
#+end_src

*** TODO iteration
#+name: imp
#+begin_src pascal
  function TNode.next : TNode;
  begin
    result := _next;
  end;
#+end_src
*** TODO deletion
#+name: imp--
#+begin_src pascal
  procedure TNode.del( key : TKey );
  begin
  end;
#+end_src

*** TODO bulk-loading
#+name: imp----
#+begin_src pascal
  constructor TNode.bulk( pairs : TKeyValPair );
  begin
  end;
#+end_src

** TODO [0/1] The container class (TTree)
*** TODO [0/0] constructor
#+name: imp
#+begin_src pascal

  constructor TTree.Create;
  begin
    root := TNode.Create;
    root.isleaf := true;
  end;

#+end_src
*** put
#+name: imp
#+begin_src pascal
  procedure TTree.put( key : TKey; val : TVal );
  begin
    root.put( key, val )
  end;
#+end_src
*** enumerator
#+name: imp
#+begin_src pascal
  function TTree.GetEnumerator : TIter;
  begin
    result := TIter.Create( self )
  end;

#+end_src

** TODO [4/4] TIter : iterator for the Tree class
*** TEXT Walking a B+-Tree
The leaf nodes of a B+Tree are linked together to form a chain, making it easy to iterate over the links in sequential order.

*** DONE constructor
#+name: imp
#+begin_src pascal
  constructor TIter.Create( aTree : TTree );
  begin
    self.tree := aTree;
    self.Reset;
  end;
#+end_src
*** DONE reset
#+name: imp
#+begin_src pascal
  procedure TIter.Reset;
  begin
    // this should walk down to the first (leftmost) leaf node
    self.node := self.tree.root.locate(-maxint)
  end;
#+end_src

*** DONE getcurrent
#+name: imp
#+begin_src pascal
  function TIter.GetCurrent : TObject;
  begin
    result := node.childvals[step];
  end;
#+end_src

*** DONE movenext
#+name: imp
#+begin_src pascal
  function TIter.MoveNext : Boolean;
  begin
    result := false;
    if assigned(node) then begin
      inc(step);
      if (node.childkeys[step] = empty) then begin
        step := 0;
        node := node.next;
      end;
      result := assigned(node);
    end
  end;
#+end_src

** OUTPUT: =bp.pas=
#+begin_src pascal :tangle "~/b/go/bp.pas" :padline yes :noweb tangle
  { NOTE : this file is generated from ../ref/bplus.org , so...
    --->> DON'T EDIT THIS FILE! <<--- }
  <<interface>>
  implementation
    <<imp>>
  end.
#+end_src

* Usage: An Indexed Triple Store
** declarations
#+name: test
#+begin_src pascal :tangle "~/b/go/bpdemo.pas" :padline yes :noweb tangle
  {$H+}{$mode objfpc}
  program bpdemo;
  uses bp;

    const kMax = 99;
    type
      TTriple = class
        sub, rel, obj : integer;
        constructor Create( SubId, RelId, ObjId : integer );
        procedure Print;
        // function reversed : IEnumerator;
      end;

    constructor TTriple.Create( SubId, RelId, ObjId : integer );
    begin
      sub := subid;
      rel := relid;
      obj := objid;
    end;

    procedure TTriple.Print;
    begin
      writeln( sub:8, rel:8, obj:8 );
    end;

    var
      subs, rels, objs : bp.TTree;
      trip : TObject;
      i    : integer;
  begin
    <<main>>
  end.
#+end_src
** <<main>>
*** populate
#+name:main
#+begin_src pascal

  randomize;

  { create three indices for a triplestore }
  subs := bp.TTree.create;
  rels := bp.TTree.create;
  objs := bp.TTree.create;

  { generate and index a bunch of random triples }
  for i := 1 to 100 do begin
    trip := TTriple.create(random(kMax),random(kMax),random(kMax));
    with TTriple(trip) do begin
      subs.put( sub, trip );
      rels.put( rel, trip );
      objs.put( obj, trip );
    end;
  end;
#+end_src
*** print forward
#+name: main
#+begin_src pascal
      { print them in order by each index }
      writeln('--subs--');
      for trip in subs do TTriple(trip).print;
      writeln('--rels--');
      for trip in rels do TTriple(trip).print;
      writeln('--objs--');
      for trip in objs do TTriple(trip).print;
#+end_src
*** TODO print backward
#+begin_src pascal
    { and reversed }
    writeln('--subs desc--');
    for trip in subs.reversed do TTriple(trip).print;
    writeln('--objs desc--');
    for trip in objs.reversed do Triple(trip).print;
    writeln('--rels desc--');
    for trip in rels.reversed do TTriple(trip).print;
#+end_src
* end
