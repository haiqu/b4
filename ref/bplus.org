#+title: b+ trees
#+author: michal j wallace

* [0/2] overview
** TODO what is a b+ tree?
** TODO what problem does a b+ tree overcome?
* Interface
#+name: interface
#+begin_src pascal
  
  { B+ Trees for pascal }
  {$mode objfpc}
  unit bp;
  interface
    const empty = -maxint;
    type
      TKey = integer;
      TVal = pointer;
      TNode = class
        //constructor create;
        //constructor create( up : TNode );
        procedure put( key : TKey; val : TVal );
        //procedure del( key : TKey );
        //function get( key : TKey ): TVal;
        //function has( key : Tkey ): boolean;
      private
        leaf : boolean;
        _parent : TNode;
        childkeys : array of TKey;
        childvals  : array of pointer;
        function locate( key : TKey ): TNode;
        function insert( key : TKey ): cardinal;
        function full : boolean;
        procedure split;
        procedure rebalance;
        function firstkey : TKey;
      end;
  
#+end_src

* [2/4] Algorithms (roughly following [[http://en.wikipedia.org/wiki/B%2B_tree][wikipedia: B+ Trees]])
** DONE [1/1] location
*** DONE TNode.locate
#+name: imp
#+begin_src pascal

  { This search routine always succeeds, since it finds the location 
    where the key /should/ be in the tree, whether it's /actually/
    there or not. }
  function TNode.locate( key : TKey ) : TNode;
    var i : integer = 0;
  begin
    if leaf then result := self
    else begin
      { find first child key less the new key }
      while (key >= childkeys[ i ])
        and (i < length(childkeys))
        do inc( i );
      { have the child do what we just did }
        result := TNode(childvals[ i ]).locate( key );
    end
  end;

#+end_src

** DONE [6/6] insertion
*** DONE TNode.put
#+name: imp
#+begin_src pascal
  procedure TNode.put( key : TKey; val : TVal );
  begin
    if leaf then
      begin
        childvals[insert( key )] := val;
        rebalance;
      end
    else locate( key ).put( key, val )
  end;
#+end_src

*** DONE TNode.insert
#+name: imp
#+begin_src pascal
  function TNode.insert( key : TKey ) : cardinal;
   var i : integer;
  begin
    i := length(childvals);
    { find the first empty slot by scanning backward from the end: }
    while (i > 0) and (childkeys[i-1] = empty) do dec( i );

    { Make room for the key, keeping the sequence ordered. }
    { We needn't check for i>0 because childkeys[0] is always -maxint }
    while (childkeys[i-1] > key) do
      begin
        childvals[i] := childvals[i-1];
        childkeys[i] := childkeys[i-1];
        dec( i );
      end;

    { finally, fill the hole we just made, and return its location }
    childkeys[ i ] := key;
    childvals[ i ] := nil;
    result := i
  end;
#+end_src
*** DONE TNode.rebalance
#+name: imp
#+begin_src pascal
  procedure TNode.rebalance;
  begin
    if full then split
  end;
#+end_src

*** DONE TNode.full
#+name: imp
#+begin_src pascal
  function TNode.full : boolean;
  begin
    result := childkeys[high(childkeys)] <> empty;
  end;
#+end_src

*** DONE TNode.split
#+name: imp
#+begin_src pascal
  procedure TNode.split;
    var newnode: TNode;
    <<copyhalf>>
  begin
    newnode := TNode.create;
    copyhalf;
    _parent.put( newnode.firstkey, newnode );
  end;
#+end_src
*** DONE <<copyhalf>>
#+name: copyhalf
#+begin_src pascal
  procedure copyhalf; 
    var i, half : integer;
  begin
    half := length(childkeys) div 2;
    for i := half to high(childkeys) do
    begin
      newnode.childkeys[i-half] := childkeys[i];
      newnode.childvals[i-half] := childvals[i];
      childkeys[i] := empty;
      childvals[i] := nil;
    end
  end;
#+end_src

*** DONE firstkey
#+name: imp
#+begin_src pascal
  { The 0th key is always -maxint, so that we can have the same }
  { number of keys and values. This way there's no special case }
  { logic. This just lets us avoid hard coding the "[1]". }
  function TNode.firstkey : TKey;
  begin
    result := childkeys[1]
  end;
#+end_src



** TODO deletion
#+name: imp--
#+begin_src pascal
  procedure TNode.del( key : TKey );
  begin
  end;
#+end_src

** TODO bulk-loading
#+name: imp----
#+begin_src pascal
  constructor TNode.bulk( pairs : TKeyValPair );
  begin
  end;
#+end_src

* OUTPUT: bp.pas
#+begin_src pascal :tangle "~/b/go/bp.pas" :padline yes :noweb tangle

  { NOTE : this file is generated from ../ref/bplus.org. edit that instead!! }

  <<interface>>
  implementation
    <<imp>>
  end.
#+end_src
