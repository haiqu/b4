#+title: b+ trees
#+author: michal j wallace

* [0/2] overview
** TODO what is a b+ tree?
** TODO what problem does a b+ tree overcome?
* Object Model and Public Interface
** unit =bp=;
#+name: interface
#+begin_src pascal
  { B+ Trees for pascal }
  {$mode objfpc}{$h+}
  unit bp;
  interface uses sysutils;

    const empty = -maxint;

    type
      TKey   = integer;
      TVal   = TObject;
      IBPlus = interface
        <<IBPlusMethods>>
      end;
      <<TNode>>
      TTree  = class; // forward reference for TIter
      <<TIter>>
      <<TTree>>

#+end_src

** Public =IBPlus= interface

#+name: IBPlusMethods
#+begin_src pascal
  procedure put( key : TKey; val : TVal );
  //procedure del( key : TKey );
  //function get( key : TKey ): TVal;
  //function has( key : Tkey ): boolean;
#+end_src

** type =TNode=
#+name: TNode
#+begin_src pascal

  TNode = class ( TInterfacedObject, IBPlus )
   public
    constructor Create( size : integer );
    <<IBPlusMethods>>
    function tostring: string; override;
   private
    isleaf      : boolean;
    _parent   : TNode;
    _next     : TNode;
    childkeys : array of TKey;
    childvals : array of TObject;
    function locate( key : TKey ): TNode;
    function inskey( key : TKey ): cardinal;
    function full : boolean;
    procedure split;
    procedure rebalance;
    function firstkey : TKey;
    function isroot : boolean;
    procedure addchild( key : TKey; kid : TNode );
    function next : TNode;
    function root : TNode;
  end;

#+end_src

** type =TTree=
#+name: TTree
#+begin_src pascal
  TTree = class
   public
    constructor Create( branchfactor : integer = 64 );
    <<IBPlusMethods>>
    function GetEnumerator: TIter;
    procedure trace;
   private
    root : TNode;
  end;
#+end_src

** type =TIter=
#+name: TIter
#+begin_src pascal
  TIter = class
  private
    tree : TTree; // only useful to support Reset
    node : TNode;
    step : integer;  // index/offset within the node
  public
    constructor Create( aTree : TTree );
    function GetCurrent : TVal;
    function MoveNext : Boolean;
    procedure Reset;
    property Current:TVal read GetCurrent;
  end;
#+end_src

* Implementation (roughly following [[http://en.wikipedia.org/wiki/B%2B_tree][wikipedia: B+ Trees]])
** TODO [4/6] Node class
*** DONE constructor
#+name: imp
#+begin_src pascal
  constructor TNode.Create( size : integer = 32 );
    var i : integer;
  begin
    isleaf := false;
    _next  := nil;
    _parent := nil;
    size := 4;

    SetLength( childkeys, size );
    SetLength( childvals, size );
    for i := 0 to size-1 do
    begin
      childkeys[i] := empty;
      childvals[i] := nil;
    end;
  end;
#+end_src
*** DONE [1/1] location
**** DONE TNode.locate
#+name: imp
#+begin_src pascal

  { This search routine always succeeds, since it finds the location
    where the key /should/ be in the tree, whether it's /actually/
    there or not. }
  function TNode.locate( key : TKey ) : TNode;
    var i : integer = 0;
  begin
    if isleaf then result := self
    else begin
      { find first child key less the new key }
      while (key >= childkeys[ i ])
        and (i < length(childkeys))
        do inc( i );
      { have the child do what we just did }
        result := TNode(childvals[ i ]).locate( key );
    end
  end;

#+end_src

*** DONE [9/9] insertion
**** DONE TNode.put
#+name: imp
#+begin_src pascal
  procedure TNode.put( key : TKey; val : TVal );
  begin
    if isleaf then
      begin
        childvals[inskey( key )] := val;
        rebalance;
      end
    else locate( key ).put( key, val )
  end;
#+end_src

**** DONE TNode.inskey
#+name: imp
#+begin_src pascal
  { insert key }
  function TNode.inskey( key : TKey ) : cardinal;
   var i : integer;
  begin
    i := length(childvals);
    { find the first empty slot by scanning backward from the end: }
    while (i > 0) and (childkeys[i-1] = empty) do dec( i );

    { Make room for the key, keeping the sequence ordered. }
    { We needn't check for i>0 because childkeys[0] is always -maxint }
    while (childkeys[i-1] > key) do
      begin
        childvals[i] := childvals[i-1];
        childkeys[i] := childkeys[i-1];
        dec( i );
      end;

    { finally, fill the hole we just made, and return its location }
    childkeys[ i ] := key;
    childvals[ i ] := nil;
    result := i
  end;
#+end_src
**** DONE TNode.rebalance
#+name: imp
#+begin_src pascal
  procedure TNode.rebalance;
  begin
    if full then split
  end;
#+end_src

**** DONE TNode.full
#+name: imp
#+begin_src pascal
  function TNode.full : boolean;
  begin
    result := childkeys[high(childkeys)] <> empty;
  end;
#+end_src

**** DONE TNode.split
#+name: imp
#+begin_src pascal
  procedure TNode.split;
    var newnode: TNode;
    <<copyhalf>>
  begin
    newnode := TNode.create( length( childkeys ));
    newnode.isleaf := true;
    newnode._next := _next;
    _next := newnode;
    copyhalf;
    childvals[high(childvals)] := newnode;
    if isroot then begin
      _parent := TNode.create( length( childkeys ));
      _parent.isleaf := false;
      _parent.addchild( self.firstkey, self )
    end;
    _parent.addchild( newnode.firstkey, newnode )
  end;
#+end_src

**** DONE <<copyhalf>>
#+name: copyhalf
#+begin_src pascal
  procedure copyhalf;
    var i, half : integer;
  begin
    half := length(childkeys) div 2;
    for i := half to high(childkeys) do
    begin
      newnode.childkeys[i-half] := childkeys[i];
      newnode.childvals[i-half] := childvals[i];
      childkeys[i] := empty;
      childvals[i] := nil;
    end
  end;
#+end_src

**** DONE TNode.isroot
#+name: imp
#+begin_src pascal
  function TNode.isroot : boolean;
  begin
    result := not assigned(_parent);
  end;
#+end_src

**** DONE firstkey
#+name: imp
#+begin_src pascal
  { The 0th key is always -maxint, so that we can have the same }
  { number of keys and values. This way there's no special case }
  { logic. This just lets us avoid hard coding the "[1]". }
  function TNode.firstkey : TKey;
  begin
    result := childkeys[1]
  end;
#+end_src

**** DONE addchild
#+name: imp
#+begin_src pascal
  procedure TNode.addchild( key : TKey; kid : TNode );
  begin
    childvals[inskey( key )] := kid;
    rebalance;
  end;
#+end_src

*** DONE iteration
#+name: imp
#+begin_src pascal
  function TNode.next : TNode;
  begin
    result := _next;
  end;
#+end_src

*** DONE finding the new root of the tree
#+name: imp
#+begin_src pascal
  function TNode.root : TNode;
  begin
    if isroot
      then result := self
      else result := _parent.root
  end;
#+end_src

*** TODO debugging with .trace
#+name: imp
#+begin_src pascal
  procedure TTree.trace;
  begin
    writeln(self.root.tostring);
  end;

  function TNode.ToString : string;
  var s : string; i : integer;
  begin
    setlength(s, 1023);
    if self.isleaf then i := 0 else i := 1;
    i := 0;
    s := '[';
    repeat
      if self.childkeys[i] = empty
        then s := s + ' <: '
        else s := s + ' ' + IntToStr(self.childkeys[ i ]) + ': ';
      if assigned(self.childvals[ i ])
        then s := s + self.childvals[ i ].ToString
        else s := s + '_';
      inc(i)
    until self.childkeys[i] = empty;
    s := s + ' ]';
    result := s;
  end;

#+end_src
*** TODO deletion
#+name: imp--
#+begin_src pascal
  procedure TNode.del( key : TKey );
  begin
  end;
#+end_src

*** TODO bulk-loading
#+name: imp----
#+begin_src pascal
  constructor TNode.bulk( pairs : TKeyValPair );
  begin
  end;
#+end_src

** TODO [0/1] The container class (TTree)
*** TODO [0/0] constructor
#+name: imp
#+begin_src pascal
  constructor TTree.Create( branchfactor : integer = 64 );
  begin
    root := TNode.Create( branchfactor );
    root.isleaf := true;
  end;

#+end_src
*** put
#+name: imp
#+begin_src pascal
  procedure TTree.put( key : TKey; val : TVal );
  begin
    root.put( key, val );
    // find the new root
    root := root.root; // "for the home team"
  end;

#+end_src
*** enumerator
#+name: imp
#+begin_src pascal
  function TTree.GetEnumerator : TIter;
  begin
    result := TIter.Create( self )
  end;

#+end_src

** TODO [4/4] TIter : iterator for the Tree class
*** TEXT Walking a B+-Tree
The leaf nodes of a B+Tree are linked together to form a chain, making it easy to iterate over the links in sequential order.

*** DONE constructor
#+name: imp
#+begin_src pascal
  constructor TIter.Create( aTree : TTree );
  begin
    self.tree := aTree;
    self.Reset;
  end;
#+end_src
*** DONE reset
#+name: imp
#+begin_src pascal
  procedure TIter.Reset;
  begin
    // this should walk down to the first (leftmost) leaf node
    self.node := self.tree.root.locate(-maxint)
  end;

#+end_src

*** DONE getcurrent
#+name: imp
#+begin_src pascal
  function TIter.GetCurrent : TObject;
  begin
    result := node.childvals[step];
  end;
#+end_src

*** DONE movenext
#+name: imp
#+begin_src pascal
  function TIter.MoveNext : Boolean;
  begin
    result := false;
    if assigned(node) then begin
      inc(step);
      if (node.childkeys[step] = empty) then begin
        step := 0;
        node := node.next;
      end;
      result := assigned(node);
    end
  end;
#+end_src

** OUTPUT: =bp.pas=
#+begin_src pascal :tangle "~/b/go/bp.pas" :padline yes :noweb tangle
  { NOTE : this file is generated from ../ref/bplus.org , so...
    --->> DON'T EDIT THIS FILE! <<--- }
  <<interface>>
  implementation
    <<imp>>
  end.
#+end_src

* Usage: An Indexed Triple Store
** declarations
#+name: test
#+begin_src pascal :tangle "~/b/go/bpdemo.pas" :padline yes :noweb tangle
  {$mode objfpc}
  {$H+}
  program bpdemo;
  uses bp, sysutils;

    const kMax = 99;
    type
      TTriple = class
        sub, rel, obj : integer;
        constructor Create( SubId, RelId, ObjId : integer );
        procedure Print;
        function tostring: string; override;
        // function reversed : IEnumerator;
      end;

    constructor TTriple.Create( SubId, RelId, ObjId : integer );
    begin
      sub := subid;
      rel := relid;
      obj := objid;
    end;


    var building : boolean = true;
    function TTriple.ToString : string;
    begin
      if building
        then result := '.'
        else result := '(' + IntToStr( sub ) +
                       ', ' + IntToStr( rel ) +
                       ', ' + IntToStr( obj ) +
                       ')';
    end;

    procedure TTriple.print;
    begin
      writeln( self.tostring )
    end;

    <<main>>
  end.

#+end_src
** <<main>>
*** populate
#+name:main
#+begin_src pascal
    var
      subs, rels, objs : bp.TTree;
      trip             : TObject;
      i, j, k, tmp     : integer;
      nums             : array [0..2, 0..99] of byte;
  begin
  
  randomize;
  
  { create three indices for a triplestore }
  subs := bp.TTree.create(4); // just to make the trace easier to read
  rels := bp.TTree.create;
  objs := bp.TTree.create;
  
  { generate the numbers 0..99 in three columns }
  for j := 0 to 2 do for i := 0 to 99 do nums[j][i] := i;
  
  { shuffle the columns independently }
  for j := 0 to 2 do for i := 0 to 2500 do
  begin
    k := random(99);
    tmp := nums[j][k];
    nums[j][k] := nums[j][k+1];
    nums[j][k+1] := tmp;
  end;
  
  { initial index: }
  writeln('initial index:');
  subs.trace;
  
  { generate and index the random triples }
  for i := 0 to 99 do begin
    trip := TTriple.create(nums[0][i], nums[1][i], nums[2][i]);
    with TTriple(trip) do begin
      subs.put( sub, trip );
      rels.put( rel, trip );
      objs.put( obj, trip );
  
      { for debugging, show one of the indices being built step by step }
      writeln;
      writeln('adding key:', sub:2 ); //, '-> ', rel:2, ', ',  obj:2 );
      subs.trace;
    end;
  end;
  #+end_src
*** print forward
#+name: main
#+begin_src pascal
   building := false;
  { print them in order by each index }
  writeln('--subs--');
  for trip in subs do TTriple(trip).print;
  writeln('--rels--');
  for trip in rels do TTriple(trip).print;
  writeln('--objs--');
  for trip in objs do TTriple(trip).print;
#+end_src
*** TODO print backward
#+begin_src pascal
    { and reversed }
    writeln('--subs desc--');
    for trip in subs.reversed do TTriple(trip).print;
    writeln('--objs desc--');
    for trip in objs.reversed do Triple(trip).print;
    writeln('--rels desc--');
    for trip in rels.reversed do TTriple(trip).print;
#+end_src
* end
