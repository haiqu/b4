{ -----------------------------------------------------------------

  pre : a pattern recognition engine

  copyright (c) 2012 michal j wallace
  see ../LICENSE.org for ( MIT-style ) licensing details

---------------------------------------------------------------- }
{$i xpc.inc }
unit pre;
interface uses xpc;

  type
    charset = set of Char;
    pattern = class
      function match( var s : string ) : boolean; virtual; abstract;
    end;
    pattern_array = array of pattern;
    patterns = ^pattern_array;

  { primitive : character classes }
  function nul : pattern;
  function lit( const c  : char ) : pattern;
  function any( const cs : charset ) : pattern;

  { regular expresisons }
  function opt( const p : pattern ) : pattern;   // [ ], like regexp '?'
  function rep( const p : pattern ) : pattern;   // { }, like regexp '*'
  function alt( const ps : patterns ) : pattern; // "|"
  function seq( const ps : patterns ) : pattern; // " " ( concatenation )

  { recursion support }
  function sub( const iden : string ) : pattern;
  procedure def( const iden : string ; p : pattern );

  { support for multiple grammars }
  procedure new_grammar( const iden : string );
  procedure end_grammar;
  procedure use_grammar( const iden : string );


implementation

  { dictionary routines }
  procedure def(const iden : string ; p : pattern );
  begin
  end;

  { support for multiple grammars }
  procedure new_grammar( const iden : string ); begin end;
  procedure end_grammar; begin end;
  procedure use_grammar( const iden : string ); begin end;


  { these hand-written routines are used by the objects
    generated in pre_gen.pas }

  function match_nul : boolean; inline;
  begin result := true;
  end;

  function match_lit( const c : char ) : boolean; inline;
  begin result := true;
  end;

  function match_any( const cs : charset ) : boolean; inline;
  begin result := true;
  end;

  function match_opt( const pat : pattern ) : boolean; inline;
  begin result := true;
  end;

  function match_rep( const pat : pattern ) : boolean; inline;
  begin result := true;
  end;

  function match_alt( const pats : patterns ) : boolean; inline;
  begin result := true;
  end;

  function match_seq( const pats : patterns ) : boolean; inline;
  begin result := true;
  end;

  function match_sub( const iden : string ) : boolean; inline;
  begin result := true;
  end;

  {$i pre_gen.pas } // generated by pre_gen.py when you run make


  { initialization : seed the engine with a simple ebnf parser }

  // this is sort of a workaround for the objfpc syntax
  //
  // given the grammar rule:
  //
  //    expr = term  { "|" term } .
  //
  //  I want to say:
  //
  //    def( 'expr', seq([ sub( 'term' ), rep([ lit( '|' ), sub( 'term' )])]));
  //
  // unfortunately, as far as i can tell, there's no way to express a
  // literal dynamic array like this. ( if there is, i'd love to hear
  // hear about it )
  //
  // in the meantime, i made this little stack machine instead.
  // it's only purpose is to make the ebnf grammar below easier to read.

  var pats : patterns; n : integer;

  function  ps : patterns; { creates a new patterns array }
  begin
    n := 0; new( pats ); result := pats
  end;

  procedure p( pat : pattern ); { appends to the last array }
  begin
    inc( n ); setlength( pats^, n ); pats^[ n ] := pat;
  end; { p }


begin { hand-built bootstrap parser for ebnf grammars }
  new_grammar( 'ebnf' );

  // syntax = { rule } .
  def( 'syntax', rep( sub( 'rule' )));

  // rule = iden "=" expr .
  def( 'rule', seq( ps ));
    p( sub( 'iden' ));
    p( lit( '=' ));
    p( sub( 'expr' ));
    p( lit( '.' ));

  // iden = alpha { alpha | digit } .
  def( 'iden', seq( ps ));
    p( sub( 'alpha' ));
    p( sub( 'iden-tail' ));
  def( 'iden-tail', rep( alt( ps )));
    p( sub( 'alpha' ));
    p( sub( 'digit' ));

  // alpha = 'a' | ... | 'z' | 'A' | ... | 'Z'
  def( 'alpha',   any([ 'a'..'z', 'A'..'Z' ]));

  // digit = '0' | ... | '9'
  def( 'digit',   any([ '0'..'9' ]));

  // expr = term  { "|" term } .
  // !! this one has a rep inside a seq. i broke it into two parts
  //    rather than complicate the builder framework further
  def( 'expr', seq( ps ));
    p( sub( 'term' ));
    p( sub( 'expr-tail' ));
  def( 'expr-tail', rep( seq( ps )));
    p( lit( '|' ));
    p( sub( 'term' ));

  // term = { factor }
  def( 'term', rep( sub( 'factor' )));

  // rep = "{" expr "}" .
  def( '{rep}', seq( ps ));
    p( lit( '(' ));
    p( sub( 'expr' ));
    p( lit( ')' ));

  // opt = "[" expr "]" .
  def( '[opt]', seq( ps ));
    p( lit( '[' ));
    p( sub( 'expr' ));
    p( lit( ']' ));

  // grp = "(" expr ")" .
  def( '(grp)', seq( ps ));
    p( lit( '(' ));
    p( sub( 'expr' ));
    p( lit( ')' ));

  // factor = iden | string | rep | opt | grp .
  def( 'factor', alt( ps ));
    p( sub( 'iden' ));
    p( sub( 'string' ));
    p( sub( '{rep}' ));
    p( sub( '[opt]' ));
    p( sub( '(grp)' ));

  // str = """ { str-esc | any other character } """
  def( 'str', seq( ps ));
    p( lit( '"' ));
    p( sub( 'str-esc' ));
    p( lit( '"' ));

  // esc = "" ( "" | """ )
  //
  // Note : I use the ascii escape character as an escape character.
  // That is its purpose. :)
  //
  // If you can't see it, in the line above, please consider filing
  // a bug report with whoever makes the tool you're using.
  def( 'str-esc', alt( ps ));
    p( sub( 'escaped' ));
    p( any([ #0 .. #255 ] - [ '"', #27 ])); // here, "-" means 'excluding'
  def( 'escaped', seq( ps ));
    p( lit( #27 ));
    p( any([ #0 .. #255 ]));

  end_grammar;
end.
