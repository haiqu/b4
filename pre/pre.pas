{ -----------------------------------------------------------------

  pre : a pattern recognition engine

  copyright (c) 2012 michal j wallace
  see ../LICENSE.org for ( MIT-style ) licensing details

---------------------------------------------------------------- }
{$i xpc.inc }
unit pre;
interface uses xpc, stacks, ll, ascii, num;

  type

    Marker  = class end;
    MarkerStack = specialize Stack< Marker >;

    Source = class
      procedure next( var ch : char );   virtual; abstract;
      procedure mark( var mk : Marker ); virtual; abstract;
      procedure back( var mk : Marker ); virtual; abstract;
      function consumed : string; virtual; abstract;
    end;

    StringSource = class ( Source )
      constructor create( s : string );
      procedure next( var ch : char );   override;
      procedure mark( var mk : Marker ); override;
      procedure back( var mk : Marker ); override;
      function consumed : string; override;
    private
      idx : word;
      str : string;
    end;

    Token = class
      sym, pos, len : cardinal;
    end;

    CharSet = set of Char;

    matcher = class; // forward reference
    Pattern = class
      function match( m : matcher )  : boolean; virtual; abstract;
      function matches( s : string ) : boolean; virtual; abstract;
    end;

    patterns = array of pattern;

    { matcher contains the hand-written methods that
      actually carry out the work of matching things.

      this class definition also serves as the input
      to pre_gen.py, which generates a bunch of helper
      classes and functions }

    matcher = class
      src   : Source;
      ch    : Char;
      marks : MarkerStack;
      point : int32;

      constructor create;
      constructor create( s : string );
      procedure match( s : source; rule: string );
      function consumed : string;

    { matcher class internals }
    protected

      { primitive : character classes }
      function nul : boolean;
      function sym( const c  : char ) : boolean;
      function any( const cs : charset ) : boolean;
      function lit( const s  : string) : boolean;

      { regular expressions }
      function opt( p : pattern ) : boolean;   // like regexp '?'
      function rep( p : pattern ) : boolean;   // like '*'
      function alt( const ps : patterns ) : boolean; // like "|"
      function seq( const ps : patterns ) : boolean; // like "(...)"

      { recursion support }
      function def( const iden : string; p : pattern ) : boolean;
      function sub( const iden : string ) : boolean;

      { state management }
      procedure next;
      procedure mark;
      procedure back;
      procedure keep;

    end;


  { support for multiple grammars }
  procedure new_grammar( const iden : string );
  procedure end_grammar;
  procedure use_grammar( const iden : string );

  {$i pre.intf.inc }  // generated by pre_gen.py

  { helper routines : only  for bootstrapping and testing }
  function ps( len : cardinal ) : patterns; { creates a new patterns array }
  procedure p( pat : pattern ); { appends to the last array }

implementation

  {$i pre.impl.inc }  // generated by pre_gen.py

  type defarray = array of DefPattern;
  var defs : defarray;

  { support for multiple grammars }
  procedure new_grammar( const iden : string ); begin end;
  procedure end_grammar; begin end;
  procedure use_grammar( const iden : string ); begin end;

  constructor matcher.create;
  begin self.create( '' );
  end;

  constructor matcher.create( s	: string );
  begin
    self.src := StringSource.create( s );
    self.marks.init( 32 );
  end;

  procedure matcher.match( s : source; rule : string );
  begin
    self.src := s;
    self.sub( rule )
  end;

  function matcher.consumed : string;
  begin result := self.src.consumed;
  end;


  { these hand-written routines are used by the objects
    generated in pre_gen.pas }

  { nul : always matches, without consuming any characters }
  function matcher.nul : boolean;
  begin
    result := true;
  end;

  { sym : tests equality with a specific symbol }
  function matcher.sym( const c : char ) : boolean;
  begin
    mark; next;
    result := self.ch = c;
    if result then keep else back;
  end;

  { any : tests membership in a set of characters }
  function matcher.any( const cs : charset ) : boolean;
  begin
    mark; next;
    result := self.ch in cs;
    if result then keep else back;
  end;

  { lit : tests equality with a specific symbol }
  function matcher.lit( const s : string ) : boolean;
    var i : word;
  begin
    mark;
    result := true;
    for i := 1 to length( s ) do begin
      next;
      if self.ch <> s[ i ] then result := false;
    end;
    if result then keep else back;
  end;

  { alt : can match any one of the given patterns }
  // !! NOTE: in this implementation, the first match wins, so it acts
  //    like a parsing expression grammar. Most of the languages I'm
  //    parsing are LL(1), so I don't think this actually makes any
  //    difference.
  function matcher.alt( const ps : patterns ) : boolean;
    var i : integer = 0 ; found : boolean = false;
  begin
    repeat
      mark;
      found := ps[ i ].match( self );
      inc( i );
      if found then keep else back;
    until found or ( i > high( ps ));
    result := found;
  end;


  { opt : ( optional ) tries to match a pattern,
    but if the pattern doesn't match, it backtracks
    and returns true anyway.
    algebraically, opt p = alt ( p , nul ) }
  function matcher.opt( p : pattern ) : boolean;
  begin
    mark;
    if p.match( self ) then keep else back;
    result := true;
  end;

  { rep : ( repeating ) is like opt, but it will keep consuming
    input until the underlying pattern fails. since matching 0
    copies is still a match, rep always succeeds }
  function matcher.rep( p : pattern ) : boolean;
  begin
    repeat
      mark;
      result := p.match( self );
      if result then keep else back;
    until not result;
    result := true;
  end;

  { seq : ( sequence ) simply matches each pattern from left to right.
    it succeeds if and only if each pattern in the sequence succeeds. }
  function matcher.seq( const ps : patterns ) : boolean;
    var i : integer;
  begin
    mark;
    i := low( ps ); result := true;
    repeat
      result := result and ps[ i ].match( self );
      inc( i )
    until ( i > high( ps )) or not result;
    if result then keep else back;
  end;

  { dictionary routines }

  { def assigns a name to the specified pattern.
    the only reason this is a function rather than a procedure is to
    avoid special cases in the code generator }
  function matcher.def( const iden : string ; p : pattern ) : boolean;
    var len : cardinal;
  begin
    len := length( defs );
    setlength( defs, len + 1 );
    defs[ len ].iden := iden;
    defs[ len ].p := p;
    result := true;
  end;

  { lookup : searches through the dictionary backward, so that the last
    entry added is the one returned }
  function lookup( const iden : string; var p : pattern ) : boolean;
    var i : integer; found : boolean = false;
  begin
    i := length( defs ) - 1;
    while ( i > -1 ) and not found do begin
      found := defs[ i ].iden = iden;
      if found then p := defs[ i ];
      dec( i )
    end;
    result := found;
  end;

  { sub : invokes a rule ( provided it's found in the dictionary ) }
  function matcher.sub( const iden : string ) : boolean;
    var p : pattern;
  begin
    if lookup( iden, p ) then result := p.match( self )
    else begin writeln( 'couldn''t find sub: ', iden ); halt end
  end;


  procedure matcher.next;
  begin
    self.src.next( self.ch )
  end;

  procedure matcher.mark;
    var mk : marker;
  begin
    self.src.mark( mk );
    self.marks.push( mk );
  end;

  procedure matcher.keep;
  begin
    self.marks.pop;
  end;

  procedure matcher.back;
    var mk : marker;
  begin
    mk := self.marks.pop;
    self.src.back( mk )
  end;


  type StringMarker = class( Marker )
    idx : word
  end;

  constructor StringSource.create( s : string );
  begin
    self.idx := 0;
    self.str := s;
  end;

  procedure StringSource.next( var ch : char );
  begin
    if self.idx = length( self.str ) then ch := ascii.EOT
    else begin
      inc( self.idx );
      // writeln(' idx:', self.idx, '  str:', self.str  );
      ch := self.str[ self.idx ];
    end;
  end;

  procedure StringSource.mark( var mk : Marker );
  begin
    mk := StringMarker.create;
    ( mk as stringmarker ).idx := self.idx;
  end;

  procedure StringSource.back( var mk : Marker );
  begin
    assert( mk is stringmarker );
    self.idx := ( mk as stringmarker ).idx;
  end;

  function StringSource.consumed : string;
  begin
    result := copy( self.str, 1, self.idx );
  end;

{ initialization : seed the engine with a simple ebnf parser }

  // this is sort of a workaround for the objfpc syntax
  //
  // given the grammar rule:
  //
  //    expr = term  { "|" term } .
  //
  //  I want to say:
  //
  //    def( 'expr', seq([ sub( 'term' ), rep([ lit( '|' ), sub( 'term' )])]));
  //
  // unfortunately, as far as i can tell, there's no way to express a
  // literal dynamic array like this. ( if there is, i'd love to hear
  // hear about it )
  //
  // in the meantime, i made these little builder functions. their
  // only purpose is to make the ebnf grammar below easier to read.

  var
    build     : patterns;
    build_max : integer = 0;
    build_idx : integer = 0;

  function ps( len : cardinal ): patterns; { creates a new patterns array }
  begin
    if build_max <> build_idx then
      die( 'expected ' + n2s( build_max ) +
	  ' patterns, got ' + n2s( build_idx + 1 ))
    else begin
      setlength( build, len ); // setlength makes a new copy
      result := build;
      build_max := len;
      build_idx := 0;
    end
  end;

  procedure p( pat : pattern ); { appends to the last array }
  begin
    build[ build_idx ] := pat;
    inc( build_idx );
  end;

initialization
  { hand-built bootstrap parser for ebnf grammars
    This uses the simplified pattern constructors
    from the generated include file. }

  new_grammar( 'ebnf' );

  // syntax = { rule } .
  def( 'syntax', rep( sub( 'rule' )));

  // rule = iden "=" expr .
  def( 'rule', seq( ps( 4 )));
    p( sub( 'iden' ));
    p( lit( '=' ));
    p( sub( 'expr' ));
    p( lit( '.' ));

  // iden = alpha { alpha | digit } .
  def( 'iden', seq( ps( 2 )));
    p( sub( 'alpha' ));
    p( sub( 'iden-tail' ));
  def( 'iden-tail', rep( alt( ps( 2 ))));
    p( sub( 'alpha' ));
    p( sub( 'digit' ));

  // alpha = 'a' | ... | 'z' | 'A' | ... | 'Z'
  def( 'alpha',   any([ 'a'..'z', 'A'..'Z' ]));

  // digit = '0' | ... | '9'
  def( 'digit',   any([ '0'..'9' ]));


  // expr = term  { "|" term } .
  // !! this one has a rep inside a seq. i broke it into two parts
  //    rather than complicate the builder framework further
  def( 'expr', seq( ps( 2 )));
    p( sub( 'term' ));
    p( sub( 'expr-tail' ));
  def( 'expr-tail', rep( seq( ps( 2 ))));
    p( lit( '|' ));
    p( sub( 'term' ));

  // term = { factor }
  def( 'term', rep( sub( 'factor' )));

  // rep = "{" expr "}" .
  def( '{rep}', seq( ps( 3 )));
    p( lit( '(' ));
    p( sub( 'expr' ));
    p( lit( ')' ));

  // opt = "[" expr "]" .
  def( '[opt]', seq( ps( 3 )));
    p( lit( '[' ));
    p( sub( 'expr' ));
    p( lit( ']' ));

  // grp = "(" expr ")" .
  def( '(grp)', seq( ps( 3 )));
    p( lit( '(' ));
    p( sub( 'expr' ));
    p( lit( ')' ));


  // factor = iden | string | rep | opt | grp .
  def( 'factor', alt( ps( 5 )));
    p( sub( 'iden' ));
    p( sub( 'string' ));
    p( sub( '{rep}' ));
    p( sub( '[opt]' ));
    p( sub( '(grp)' ));

  // str = """ { str-esc | any other character } """
  def( 'str', seq( ps( 3 )));
    p( lit( '"' ));
    p( sub( 'str-esc' ));
    p( lit( '"' ));

  // esc = "" ( "" | """ )
  //
  // Note : I use the ascii escape character as an escape character.
  // That is its purpose. :)
  //
  // If you can't see it in the line above, please consider filing
  // a bug report with whoever makes the tool you're using.
  def( 'str-esc', alt( ps( 2 )));
    p( sub( 'escaped' ));
    p( any([ #0 .. #255 ] - [ '"', #27 ])); // here, "-" means 'excluding'
  def( 'escaped', seq( ps( 2 )));
    p( lit( #27 ));
    p( any([ #0 .. #255 ]));

  end_grammar;
end.
