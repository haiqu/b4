#+TITLE: ngaro implementation in free pascal

* PROGRAM ~ngaro.pas~
#+begin_src pascal :tangle "gen/ngaro.pas" :noweb tangle
  {$ifdef FPC}{$mode objfpc}{$endif}

  program ngaro;
  uses crt;

  type int32 = longint;

  <<@vtcode>>
  <<@devices>>

  var vm : ng.ngarovm;
  var vt : ngarovt;
  begin
    vt.init;
    vm.init;
    vm.loop;
  end.
#+end_src

* MODULE ng : ngaro virtual machine
#+begin_src pascal :tangle "gen/ng.pas" :noweb tangle
unit ng;

interface

  <<@interface>>

implementation
  <<@opcodes>>
  <<@stack>>
  <<@vmcode>>
end.
#+end_src

* MODULE ~st~ : stack machine
#+begin_src pascal :tangle "gen/stacks.pas" :noweb tangle
{ simple stack object }
unit stacks;

interface

  <<stack:inface>>

implementation

  <<stack:impl>>

begin
end.
#+end_src

* MODULE ~vt~
#+begin_src pascal :tangle "gen/vt.pas" :noweb tangle
#+end_src

* OVERVIEW :
** TYPE stack
#+name: stack:interface
#+begin_src pascal

  type stack = object
    sp   : integer;          // stack pointer
    cell: array of int32;    // a standard forth term
    constructor init( len:word );
    procedure dup;
    procedure swap;
    procedure drop;
    procedure overflow;
    procedure underflow;
    procedure dump;
    procedure push( v: int32 );
    function tos: int32;
    function nos: int32;
    function pop: int32;
  end;

#+end_src

** TYPE hardware
#+name: @interface
#+begin_src pascal

  type hardware = object
    constructor init;
    function send( msg:int32 ):int32; virtual;
  end;

#+end_src

** TYPE ngarovm
#+name: @interface
#+begin_src pascal

  type ngarovm = object
    ip     : integer;
    ram    : array [ 0 .. 31 ] of int32;
    port   : array [ 0 .. 15 ] of int32;
    device : array [ 0 .. 15 ] of hardware;
    data, addr : stack;
    <<machine-code>>
    constructor init;
    procedure tick;
    procedure loop;
    procedure dump;
    procedure runop( op:int32 );
    procedure runio;
  end;

#+end_src

** TYPE ngarovt
#+name: @interface
#+begin_src pascal

  type ngarovt = object
    constructor init;
  end;

#+end_src

** LIST opcodes
#+name: @opcodes
#+begin_src pascal

  const
    oNOP  = 00;  oLIT  = 01;  oDUP = 02;   oDROP = 03;
    oSWAP = 04;  oPUSH = 05;  oPOP = 06;   oLOOP = 07;
    oJMP  = 08;  oRET  = 09;  oJLT = 10;   oJGT  = 11;
    oJNE  = 12;  oJEQ  = 13;  oLOD = 14;   oSTO = 15;
    oADD  = 16;  oSUB  = 17;  oMUL = 18;   oDIVM = 19;
    oAND  = 20;  oOR   = 21;  oXOR = 22;   oSHL = 23;
    oSHR  = 24;  oZEX  = 25;  oINC = 26;   oDEC = 27;
    oIN   = 28;  oOUT  = 29;  oWAIT = 30;

#+END_SRC

* SECTION stacks
** DEF init
#+name: @stack
#+begin_src pascal

  constructor stack.init( len: word );
  begin
    sp := 0;
    setlength( cell, len );
  end;

#+end_src

** DEF tos : top of stack
#+name: @stack
#+begin_src pascal

  function stack.tos : int32;
  begin
    result := cell[ sp ];
  end;

#+end_src

** DEF nos : next on stack
#+name: @stack
#+begin_src pascal

  function stack.nos : int32;
  begin
    result := cell[ sp - 1 ];
  end;

#+end_src

** DEF dup : duplicate
#+name: @stack
#+begin_src pascal

  procedure stack.dup;
  begin
    push( tos );
  end;

#+end_src

** DEF push
#+name: @stack
#+begin_src pascal

  procedure stack.push( v : int32 );
  begin
    inc( sp );
    if sp >= length( cell ) then overflow
    else cell[ sp ] := v;
  end;

#+end_src

** DEF pop
#+name: @stack
#+begin_src pascal

  function stack.pop : int32;
  begin
    result := tos;
    drop;
  end;

#+end_src

** DEF drop
#+name: @stack
#+begin_src pascal

  procedure stack.drop;
  begin
    dec( sp );
    if sp < 0 then underflow;
  end;

#+end_src

** DEF swap
#+name: @stack
#+begin_src pascal

  procedure stack.swap;
    var t : int32;
  begin
    if sp >= 2 then
      begin
        t := tos;
        cell[ sp ] := nos;
        cell[ sp - 1 ] := t;
      end
    else underflow;
  end;

#+end_src

** DEF overflow
#+name: @stack
#+begin_src pascal

  procedure stack.overflow;
  begin
    writeln( 'warning: stack overflow' );
    sp := length( cell ) - 1;
  end;

#+end_src

** DEF underflow
#+name: @stack
#+begin_src pascal

  procedure stack.underflow;
  begin
    writeln( 'warning: stack underflow' );
    sp := 0;
  end;

#+end_src


* SECTION processor
** DEF init
#+name: @vmcode
#+begin_src pascal

  constructor ngarovm.init;
  begin
    data.init( 32 );
    addr.init( 32 );
    ip := 0;
  end;

#+end_src

** DEF loop : instruction pointer's main loop
#+name: @vmcode
#+begin_src pascal

  procedure ngarovm.loop;
  begin
    repeat tick until ip >= length( ram );
  end;

#+end_src

** DEF tick : single-tick version, for sdl
#+name: @vmcode
#+begin_src pascal

  procedure ngarovm.tick;
  begin
    dump;
    runop( ram[ ip ] );
    inc( ip );
  end;

#+end_src

** DEF runop : dispatch function
#+name: @vmcode
#+begin_src pascal

  procedure ngarovm.runop( op: int32 );
    var t, n, tmp : int32;
    <<runop-helper:jump>>
    <<runop-helper:tn>>
  begin
    if ( op > oWAIT ) or ( op < oNOP ) then
      <<user-ops>>
    else
      case op of
        oNOP : { do nothing } ;
        <<stack-ops>>
        <<branch-ops>>
        <<memory-ops>>
        <<alu-ops>>
        <<port-ops>>
      else
        // TODO: assert()
        writeln('error: this should not happen ');
        readln
      end
  end;

#+end_src

** DEF runio : hardware interrupt request, triggered by oWAIT
#+name: @vmcode
#+begin_src pascal

    {
    | Ngaro machines connect via ports.                      |
    | A port is just a normal cell that's writable from both |
    | inside and outside the machine, much like a usb port.  |
    |                                                        |
    | The protocol is:                                       |
    |                                                        |
    | - write whatever you want to the ports                 |
    | - set port[ 0 ] to 0                                   |
    | - invoke the 'wait' instruction                        |
    |                                                        |
    | - the vm pauses until a device sets port[ 0 ] to 1     |
    |                                                        |
    | Note: only one device will trigger on each WAIT, and   |
    | (at least in this vm and the js one) they will always  |
    | be executed in order of ascending port numbers.        |
    |                                                        |
    | A device will only be triggered when you write a       |
    | non-zero values to its port.                           |
    |                                                        |
    }
    procedure ngarovm.runio; { triggered by the oWAIT op }
      var p: int32;
    begin
      if port[ 0 ] = 0 then
        begin
          port[ 0 ] := 1;
          for p in port do
            begin
              if port[ p ] <> 0 then
                begin
                  port[ p ] := device[ p ].send( port[ p ]);
                end;
            end;
        end;
    end;

#+end_src

* SECTION opcode implementations
** DEF runop/tn() : move ~data.tos~ and ~data.nos~ into ~t~ and ~n~
#+name: runop-helper:tn
#+begin_src pascal
  procedure tn();
  begin
    t := data.pop;
    n := data.pop;
  end;
#+end_src

** stack ops
#+name: stack-ops
#+begin_src pascal

  oDUP : data.dup;
  oDROP: data.drop;
  oSWAP: data.swap;
  oPUSH: addr.push( data.pop );
  oPOP : data.push( addr.pop );

#+end_src

** arithmetic ops
#+name: alu-ops
#+begin_src pascal

  oADD : data.push(  data.pop + data.pop );
  oSUB : data.push( -data.pop + data.pop );
  oMUL : data.push( -data.pop + data.pop );
  oDIVM: begin
           tn;
           data.push( n mod t ); { yep. mod comes first }
           data.push( n div t );
         end;
  oINC : inc( data.cell[ data.sp ] );
  oDEC : dec( data.cell[ data.sp ] );

#+end_src

** bitwise / logic ops
#+name: alu-ops
#+begin_src pascal

  oAND : data.push( data.pop AND data.pop );
  oOR  : data.push( data.pop OR data.pop );
  oXOR : data.push( data.pop XOR data.pop );
  oSHL : begin
           t := data.pop;
           data.push( data.pop shl t );
         end;
  oSHR : begin
           t := data.pop;
           data.push( data.pop shr t );
         end;

#+end_src

** branch ops
*** DEF runop/jump() : shared for all the various jumps
#+name: runop-helper:jump
#+begin_src pascal

  procedure jump();
  begin
    ip := ram[ ip + 1 ];
    while ram[ ip ] = ord( oNOP ) do inc( ip );
    dec( ip ); { compensating for the post-op inc }
  end;

#+end_src

*** jump and conditional jumps
#+name: branch-ops
#+begin_src pascal

  oJMP : jump();
  oJLT : begin tn(); if t <  n then jump else inc( ip ) end;
  oJGT : begin tn(); if t >  n then jump else inc( ip ) end;
  oJNE : begin tn(); if t <> n then jump else inc( ip ) end;
  oJEQ : begin tn(); if t =  n then jump else inc( ip ) end;

#+end_src

*** return
#+name: branch-ops
#+begin_src pascal

  oRET : ip := addr.pop;

#+end_src

*** loop
#+name: branch-ops
#+begin_src pascal

  oLOOP: begin
           dec( data.cell[ data.sp ] );
           tmp := ram[ ip ];
           if data.cell[ data.sp ] > 0 then
             ip := ram[ ip + 1 ]
           else
             begin
               inc( ip );
               data.pop;
             end
         end;

#+end_src

*** zex : exit (return) if TOS = 0 ( sort of like ~assert~ )
#+name: branch-ops
#+begin_src pascal

  oZEX : if data.cell[ data.sp ] = 0 then
           begin
             { sort of an assert / guard }
             data.pop;
             ip := addr.pop;
           end;

#+end_src

** memory ops
#+name: memory-ops
#+begin_src pascal

  oLIT: begin
          inc( ip );
          data.push( ram[ ip ]);
        end;
  oLOD: begin { FETCH }
          data.push( ram[ data.pop ]);
        end;
  oSTO: begin { STORE : (na-) - put nos into ram at tos }
          tn;
          ram[ t ] := ram[ n ];
        end;

#+end_src

** port ops
#+name: port-ops
#+begin_src pascal

  oIN  : begin { p-n }
           t := data.pop;
           data.push( port[ t ] );
           port[ t ] := 0;
         end;
  oOUT : begin { np- }
           port[ data.pop ] := data.pop;
         end;
  oWAIT: begin { - }
           runio;
         end;

#+end_src

* SECTION debugger (pascal-hosted)
** opcode names
#+name: @opcodes
#+begin_src pascal

  const
    mnemonic : array[ 0 .. 30 ] of string[ 5 ]
      = ( 'nop', 'lit', 'dup', 'drop',
          'swap', 'push', 'pop', 'loop',
          'jmp', 'ret', 'jlt', 'jgt',
          'jne', 'jeq', 'lod', 'sto',
          'add', 'sub', 'mul', 'divm',
          'and', 'or', 'xor', 'shl',
          'shr', 'zex', 'inc', 'dec',
          'in', 'out', 'wait'
        );

#+end_src

** dump stack
#+name: @stack
#+begin_src pascal

  procedure stack.dump;
    var s: string;
    var i: int32;
  begin
    if sp > 0 then
      for i := 1 to sp  do
        begin
          str( cell[ i ], s );
          write( s, ' ' );
        end;
    writeln;
  end;

#+end_src

** dump vm state
#+name: @vmcode
#+begin_src pascal

  procedure ngarovm.dump;
  var i: int32;
    var s: string[ 4 ];
  begin
    crt.clrscr;

    write( 'data :' ); data.dump;
    write( 'addr :' ); addr.dump;
    write( 'port :' );
    for i:= 0 to 15 do
      begin
        str( port[ i ], s );
        write( s, ' ');
      end;
    writeln;

    { mini-debugger }
    i := 0;
    repeat
      if i = ip
      then write( ' -> ' )
      else write( '    ' );
      write( mnemonic[ ram[ i ]] );
      if ram[ i ] in [ oLIT, oLOOP, oJMP, oJGT, oJLT, oJNE, oJEQ ] then
        begin
          inc( i );
          str( ram[ i ], s );
          write(' ');
          write( s );
        end;
      writeln;
      inc( i );
    until i = length( self.ram );
    readln;
  end;

#+end_src

* SECTION devices
** general hardware
#+name: @devices
#+begin_src pascal

  function hardware.send( msg: int32 ): int32;
  begin
    result := 0;
  end;

#+end_src

** --
# all of these were ported from ngaro.js,
# except file/io and enhanced text
*** ITEM port 0 : i/o events

Port 0 isn't connected to a device. It's just used to signal that one side or the other has data to transfer.

*** TODO port 1 : keyboard
**** keyboard events
  TYPE KeyboardEvent = SDL.TSDL_KeyboardEvent;
****
  if (ports[1] == 1 && inputMethod == 0)
  {
    ports[1] = lastKey;
    lastKey = 0;
    return;
  }
  if (ports[1] == 1 && inputMethod == 1)
  {
    ports[1] = tib.charCodeAt(0);
    tib = tib.substr(1, tib.length - 1);
    lastKey = 0;
    return;
  }

*** TODO port 2 : simple text output

portHandlers[2] = function()
{
  Term.renderChar( data.pop );
  ports[ 2 ] = 0;
}

*** SKIP port 3 : video update

This can probably be used for double-buffered graphics.

*** TODO port 4 : file i/o

portHandlers[4] = function()
{
  ports[4] = 0;
  saveImage();
}

*** TODO port 5 : querying the vm
#+begin_src pascal

  case vm.port[ 5 ] of
    -1  : res := IMAGE_SIZE;
    -2  : res := FB_EXISTS;
    -3  : res := FB_WIDTH;
    -4  : res := FB_HEIGHT;
    -5  : res := data.sp;
    -6  : res := addr.sp;
    -7  : res := -1;
    -8  : begin
      {
         var foo = new Date;
         var unixtime_ms = foo.getTime();
         var unixtime = parseInt(unixtime_ms / 1000);
         res : = unixtime;
      }
         end;
    -9  : res := 0;
    -11 : res := TERM_WIDTH;
    -12 : res := TERM_HEIGHT;
  end;

#+end_src

*** SKIP port 6 : canvas
#+begin_src pascal
  portHandlers[6] = function()
  {
    switch (ports[6])
    {
      case 1:
        rxCanvasSetColor(data.pop);
        break;
      case 2:
        var x, y;
        y = data.pop;
        x = data.pop;
        fb.fillRect(x, y, 2, 2);
        break;
      case 3:
        var x, y, h, w;
        w = data.pop;
        h = data.pop;
        y = data.pop;
        x = data.pop;
        fb.strokeRect(x, y, w, h);
        break;
      case 4:
        var x, y, h, w;
        w = data.pop;
        h = data.pop;
        y = data.pop;
        x = data.pop;
        fb.fillRect(x, y, w, h);
        break;
      case 5:
        var x, y, h;
        h = data.pop;
        y = data.pop;
        x = data.pop;
        fb.fillRect(x, y, 2, h);
        break;
      case 6:
        var x, y, w;
        w = data.pop;
        y = data.pop;
        x = data.pop;
        fb.fillRect(x, y, w, 2);
        break;
      case 7:
        var x, y, w;
        w = data.pop;
        y = data.pop;
        x = data.pop;
        fb.beginPath;
        fb.arc(x, y, w, 0, Math.PI*2, true);
        fb.closePath();
        fb.stroke();
        break;
      case 8:
        var x, y, w;
        w = data.pop;
        y = data.pop;
        x = data.pop;
        fb.beginPath;
        fb.arc(x, y, w, 0, Math.PI*2, true);
        fb.closePath;
        fb.fill;
        break;
      default:
        // do nothing
    }
    ports[6] = 0;
  }

#+end_src

*** SKIP port 7 : mouse
#+begin_src pascal

  portHandlers[7] = function()
  {
    if (ports[7] == 1)
    {
      data.push(mx);
      data.push(my);
      ports[7] = 0;
    }
    if (ports[7] == 2)
    {
      data.push(mb);
      ports[7] = 0;
    }
  }

#+end_src

*** TODO port 8 : enhanced text output
**** msg 1 : ( rc- ) row col
**** msg 2 : ( n-  ) fg
**** msg 3 : ( n-  ) bg

* SECTION assembler
* SECTION virtual terminal
#+name: @vtcode
#+BEGIN_src pascal

  constructor ngarovt.init;
  begin
  end;

  constructor hardware.init;
  begin
  end;

#+END_SRC
