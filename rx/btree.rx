( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Copyright [c] 2013, Michal J Wallace                         )
( License: ISC                                                 )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )

( TODO: move to math' maybe? )
: sgn dup 0; drop 0 > [ 1 ] [ -1 ] if ; "( n-n ) signum function." :doc
: cmp - sgn ; "( ab-n ) comparison. a<b:-1 a=b:0  a>b:1 " :doc

( nil )
hex 7FFFFFFF 1+ constant nil decimal


chain: btree'

  4 variable: .fanout  "max number of children per internal node" :doc
  1 variable: .depth   "current depth of the tree" :doc
  0 variable: .root    "address of root node of the tree" :doc
  : .cmp cmp ; "( ab-c ) revectorable method, in case you want string keys" :doc

  : node+ fanout 2 * 2 + allot ( # used + n keys + n+1 addrs, where n=fanout )
    0 over fanout + !          ( set count to 0 )
  ; "( -a ) create a new node" :doc

  : new node+ dup root ! ; "( -a ) construct a new tree" :doc

  : pos? ( TODO )
  ; "( k-aof ) find addr/offset where key belongs, flag = already there" :doc

  ( is there room to add another key? )
  : room?  ( o - f ) fanout < ;

  ( p )
  : ensure ( k ) dup pos? [ + ] [ dup room? [ ins ] [ ] if ] if ;

  : put pos? [  ]
  ; "( vk-a ) put the value"

  : get?
  ; "( k - v? f ) try to fetch value v for key k. flag indicates success" :doc

---reveal---
  : -> ensure
  ; "( k-a ) find/create address of value slot for key, setting up for @/! " :doc
}}
;chain


doc{
======
btree'
======

--------
Overview
--------
Provides an implementation of B+ Trees for retro.

--------
Example:
--------

}doc

with btree'
100 -> 0 !
200 -> 2 !
300 -> 3 !
without
