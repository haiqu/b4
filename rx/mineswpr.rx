
needs sets' needs vt'  needs math'

( -- language tweaks --------------------------------------- )

: ≥ >= ; "( xy-? ) tests for x ≥ y . same as >=" :doc
: ≤ <= ; "( xy-? ) tests for x ≤ y . same as <=" :doc
: ≠ != ; "( xy-f ) just a fancy way to say !=" :doc
: dec ( a- ) -- ;
: inc ( a- ) ++ ;
: shl << ;
: shr >> ;
: odd 1 and 0 != ;
: vars| ` variables| ;
: dup2 ( xy-xyxy ) over over ;
: recurse (  -  ) @last @d->xt , ; compile-only ( from forth.rx )
: spaces [ space ] times ; "( n- ) emit n spaces" :doc
: deep push over pop swap ;
  "( xyz-xyzx ) copies the 3rd item to the top of the stack. ( dup, over, deep... )" :doc
: cop pop dup push ;
  "( -n ) copies a value from the return stack" :doc
with math'
  : randint ( n-n ) random swap mod ;
without

( -- debug tools ------------------------------------------- )
with| vt' ng' |
{{
  : .? decimal push |y .s pop |Y puts |w ;
  variable depth
  : indent 2 * spaces ;
  : [context] last @ d->name lit,, ;
  : { cr depth dup ++ @ indent |M puts space '{ putc |w ;
  : } cr depth dup @ indent -- |M '} putc space puts |w ;
---reveal---
  : !! |R .s |r "!!" puts ;
  : ?{ [context] ` { ; immediate
  : }? [context] ` } ; immediate
  : ?? depth @ spaces [context] ` .? ; immediate
    "debug tool. at runtime, this will show the stack plus the name of the word in which it was used." :doc
}}
2without

( -- imperative flow control ------------------------------- )
with ng'
: ;c  ` ?? ` ; ` immediate ; immediate
{{ ( these two should *not* be immediate. they're called by immediates )
  : .come-from here swap ! ;
  : .else-ahead 0 lit,, 0 =jump,, here 1- ;
---reveal---
: .ifso .else-ahead  ;c                "c:  -a  | r:  f-   like IF in forth" :doc
: .else ahead push .come-from pop ;c   "c:  a-a | r:   -   forth-style ELSE" :doc
: .then   .come-from ;c                "c:  a-  | r:   -   like THEN in forth" :doc
: .repeat here ;c
: .while  here ;c
: .do  .else-ahead ;c
: .again
    push       ( push the location of the jump from .do  )
      jump,,   ( compile a jump to the position marked by .while )
    pop .come-from ;c
: .until 0 lit,, =jump,, ;c           "compile the UNTIL part of a repeat loop" :doc
}}
without

( == minesweeper game ====================================== )


( -- variables --------------------------------------------- )
with sets'
  enum| ·mine ·cover ·flag ·hint |
  vars| gameOver? minefield flagCount |
without

with sets'
  16 constant W
  16 constant H
  32 constant mineCount
  create grid W H * allot

  : grid-size W H * ;
( point2d methods )
: nn 1- ; "( xy-xy ) north" :doc
: ss 1+ ; "( xy-xy ) south" :doc
: ee swap 1+ swap ; "( xy-xy ) east" :doc
: ww swap 1- swap ; "( xy-xy ) west" :doc
: ne nn ee ; "( xy-xy ) north-east" :doc
: se ss ee ; "( xy-xy ) south-east" :doc
: sw ss ww ; "( xy-xy ) south-west" :doc
: nw nn ww ; "( xy-xy ) north-west" :doc

{{
  3 elements x y q
  : xy x @ y @ ;
  : qq q @ do ;
---reveal---
  : neighbors-do q ! y ! x !
    xy nw qq    xy nn qq    xy ne qq
    xy ww qq                xy ee qq
    xy sw qq    xy ss qq    xy sw qq ;
  "( xyq- ) call q with the xy coordinates of each neighboring point" :doc
}}

: cell ( xy-a ) W * + grid + ;
  "( xy-a ) given coordinates, return the address of the cell" :doc

: inbounds? 0 H 1- within .ifso 0 W 1- within .else drop ( W- ) 0 .then ;
  "( xy-f ) is the point somewhere inside the minefield?" :doc
( cell methods )
: has? swap @ swap in? ;
  "( ce- ) does cell c contain the element e?" :doc

: uncover ·cover @excl! ;
  "( c- ) remove the cover from cell c" :doc

: armed-neighbor-count @ 8 shr ;
  "( c-n )  number of armed neighbors ( 0..8 )" :doc

: armed-neighbor-add $100 swap +! ;
  "( c- )  increment count of armed neighbors ( 0..8 )" :doc

: c>xy  grid - W /mod ;
  "( c-xy ) given a cell, return its xy coordinates." :doc

: randcell W randint H randint cell ;
  "( -a ) return a cell from the grid, at random" :doc
( grid methods )
: .fill swap W H * fill ;
  "( gx- ) fill grid g with value x" :doc

: grid-do grid-size [ 1- grid + over do ] iterd drop ;
  "( q- ) for each cell in the grid, put the cell's address in tos and run q." :doc
  ( minefield methods )
  with vt'
  : inform-neighbors c>xy
    [ dup2 inbounds? [ cell armed-neighbor-add ] [ 2drop ] if ] neighbors-do ;
    "( c- ) notify neighboring cells about the mine we just placed" :doc
  without

  : mine-add randcell dup ·mine has?
    .ifso drop recurse
    .else [ ·mine @incl! ] [ inform-neighbors ] bi
    .then ;
    "( - ) add a mine to a random cell that doesn't yet have one" :doc

  : counts-show [ dup ·mine has? .ifso uncover .else ·hint @incl! .then ] grid-do ;

without
with sets'

  : needs-fill? dup c>xy inbounds?
    .ifso ( visit cells that are still covered but do not already have hints )
       [ ·cover has? ]
       [ ·hint has? not ] bi
       and
    .else drop 0 .then ;
    "( xy-f ) should we call xy-fill! on this cell?" :doc

  ( we already know there is a cover and no hint, thanks to 'needs-fill?' )
  : cell-fill! dup ( cc ) armed-neighbor-count 0 =
    .ifso   uncover ( - )
    .else  ·hint @incl! ( - )
    .then ;
    "( c- ) actually fill the cell." :doc

  : flood dup2 cell dup needs-fill?
    .ifso cell-fill!
          dup2 nn flood
          dup2 ss flood
          dup2 ee flood
               ww flood
    .else 2drop
    .then ;
    "( xy- ) runs the floodfill algorithm on the grid at the given cell" :doc

without
( -- event handlers ---------------------------------------------- )

  : «dead»
       gameOver? -1 !
       "game over. press any key" puts getc
       [ uncover ] grid-do ;
    "( a- ) called after detonating cell a" :doc

  : «safe» c>xy flood ;
    "( a- ) called after prodding cell a with no mine" :doc

  : mineswpr-exit-hook ( revectored ) ;

with sets'
  ( -- user actions ---------------------------------------------- )
  : flaggable? dup ·flag has? .ifso drop 0 .else ·cover has? .then ;
    "( a-f ) possible to put a flag on this cell?" :doc

  : flag+ dup flaggable? [ ·flag @incl! flagCount ++ ] [ drop ] if ;
    "( a- ) place a flag on the cell" :doc

  : flag- ·flag dup2 ( cfcf ) has? [ @excl! flagCount -- ] [ 2drop ] if ;
    "( a- ) remove the flag from the cell, if present" :doc

  : prod
     dup [ flag- ] [ ·cover has? ] bi ( aa-af )
    .ifso ( af-a ) dup ·mine has? [ «dead» ] [ «safe» ] if
    .else drop
    .then ;
    "( a- ) prod the cell for a mine, and see what happens... :)" :doc

  : game-new
    gameOver? off 0 flagCount !
    ·cover as-bit grid .fill
    mineCount [ mine-add ] times ;
    "( - ) set up a new game" :doc

without
with| vt' ng' sets' |
  : |? ;
  : (x,y) dup odd [ [ |K ] ] [ [ |c ] ] if &|? ` :is
    cell dup @
    [ [ ·flag  in? ]  [ drop '! &|R dup &|? ` :is -1 ] whend
      [ ·hint  in? ]  [ armed-neighbor-count
                           '0 + &|B -1 ] whend
      [ ·cover in? ]  [ drop '- &|w -1 ] whend
      [ ·mine  in? ]  [ drop 'X &|r  0 ] whend
      [ drop   -1  ]  [ drop '- &|b  0 ] whend ] do
   [ |? '[ putc do putc |? '] putc ]
   [      space do putc space      ] if
   space ;
   "( xy- ) output cell as a string" :doc

  : show cr
    $10 [ dup 2 spaces hex dup odd [ |w ] [ |C ] if putn space
          $10 [ over (x,y) ] iter cr drop ]
    iter ;

2without without
with vt'
   ( -- display words -------------------------------------------- )

   : . putc ; : $ puts ;
   : draw clear
    |Y "                            MINESWPR.RXE" $
    |g cr
    |b "---------------------------------------------------------------------" $ |w cr
    |C "     0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F   " $
    show
    |g cr
    "type cmd at " $ '" . |w "ok" $ |g '" . ":  " $
      |Y '+ . |c " = flag  " $
      |Y '- . |c " = unflag  " $
      |Y '? . |c " = prod for mine " $
      |Y 'q . |c " = quit" $
    cr
    |g "cmd format: " $  |Y "x y " $ '[ |c . |Y "+-?" $ |c '] . |c "   " $
    |g "examples: " $ |w "5 C +" $ |y " a b -" $  |W " 2 9 ?" $ |R " q" $
                                           |Y   "   r " $ |c "= restart " $ cr
    |b "---------------------------------------------------------------------" $
    |K .s cr
    |W "ok " $ |w ;
 "draw the mineswpr ui / prompt" :doc
without
hex
chain: mswp'
  ( ui command syntax )
  : + depth 2 >= [ cell flag+ ] ifTrue ;
  : - depth 2 >= [ cell flag- ] ifTrue ;
  : ? depth 2 >= [ cell prod ]  ifTrue ;
  : a A ;
  : b B ;
  : c C ;
  : d D ;
  : e E ;
  : f F ;
  : r game-new ;
  : q mineswpr-exit-hook ;
   "minesweeper parser" :doc
;chain
decimal
( -- retro shell enhancements ------------------------------ )
with vt' with color'
: welcome
  clear
  |W "Welcome to Retro!" $ cr
  |w "Type " $ |Y "words " $
  |w "to see a list of words you can try, or " $
  |Y "play " $ |w "to play the game again." $ |w cr ;
  "a rudimentary welcome message." :doc
{{
  : mineswpr-play
    &draw &ok :is
    reset hex
    game-new
    "mswp'" find [ d->xt @ :with ] ifTrue ;

  : mineswpr-quit
    without
    reset decimal
    &grok &ok :is
    welcome ;

  &mineswpr-quit &mineswpr-exit-hook :is
---reveal---

  : play mineswpr-play ;
    "( - ) play minesweeper" :doc
}}
2without

game-new
( play )
