#+title: ar.pas : Array interface
#+INFOJS_OPT: view:content toc:nil

* The IArray Interface

Previously, we looked at the [[https://github.com/tangentstorm/xpl/blob/master/code/sq.pas][sq unit]], in which we defined a generic sequence type, whose interface looked like this:

#+begin_example pascal
  type generic ISequence<tKey, tVal> = interface
    function Length : cardinal;
    function GetItem( i : tKey ) : tVal;
    procedure SetItem( i : tKey; value : tVal );
    property item[ i : tKey ] : tVal
      read GetItem write SetItem; default;
  end;
#+end_example

We further provided an abstract class, =GSeq<tKey,tVal>=, which provides an enumerator for classes implementing =ISequence=. This allows us to loop through the values of a sequence with pascal's =for ... in ... do= syntax.

An array is a specific type of sequence that uses a continuous range of values for its keys.

Arrays in standard pascal can have arbitrary start and end indices (that is, you can declare an =array[ -5 .. 237 ]= if you like, or =array['a'..'z']=, or even =array[byte]=, which translates to =array[0..255]=, the range of the =byte= type.

However, most of the time, it's sufficient to range from zero to some maximum value, and in fact this is how dynamic arrays work in object pascal, thus we can define an interface that works very much like a dynamic array simply by specializing =ISequence= and using =cardinal= as the key type:

#+name: IArray
#+begin_src pascal
  type
    generic IArray<T> = interface (specialize ISequence<cardinal, T>)
      procedure Resize( newLength : cardinal );
      procedure Append( value : T );
    end;
#+end_src

Remember, =T= is a type variable, indicating some particular but as-yet unspecified type, as if we'd declared an =array of T=.

The two additional methods we've added indicate that we will concern ourselves here with /dynamic/ arrays, which can grow and shrink at runtime, rather than having fixed bounds.

Object pascal offers dynamic arrays, which are basically the same as static arrays, except they're allocated on the heap. You can resize them with =SetLength=, but since this can copy the entire array each time you resize it, it's not always efficient to grow the array.

Since keys in an array are a contiguous sequence of values, arrays generally store their values in a single contiguous block of RAM. This allows the compiler to use simple pointer arithmetic under the hood to 
allow very fast access to the data.

Sometimes, though, we prefer something that looks and feels like an array, but uses some other kind of storage system underneath. In this unit, we'll explore several classes that all implement this same interface, but have very different implementations under the hood.

* A simple test suite.


* Implementations
** TODO GAbstractArray
#+begin_src pascal
#+end_src

** TODO GDynArray
 #+name: ar:imp
 #+begin_src pascal

   constructor GDynArray.Create;
     begin
     end;

   destructor GDynArray.Destroy;
     begin
     end;

 #+end_src


* 
** TODO GFileArray
#+name: ar:imp
#+begin_src pascal

  constructor GFileArray.Create;
    begin
    end;

  function GFileArray.GetItem( ix : cardinal ) : T;
    begin
    end;

  procedure GFileArray.SetItem( ix : cardinal; val : T );
    begin
    end;

  destructor GFileArray.Destroy;
    begin
    end;

#+end_src

** TODO GBPlusArray

#+name: ar:imp
#+begin_src pascal

  constructor GBPlusArray.Create;
    begin
    end;

  function GBPlusArray.GetItem( ix : cardinal ) : T;
    begin
    end;

  procedure GBPlusArray.SetItem( ix : cardinal; val : T );
    begin
    end;

  destructor GBPlusArray.Destroy;
    begin
    end;

#+end_src

** TODO GEmbeddedArray
#+name: ar:imp
#+begin_src pascal

  constructor GEmbeddedArray.Create;
    begin
    end;

  function GEmbeddedArray.GetItem( ix : cardinal ) : T;
    begin
    end;

  procedure GEmbeddedArray.SetItem( ix : cardinal; val : T );
    begin
    end;

  destructor GEmbeddedArray.Destroy;
    begin
    end;

#+end_src




* Appendix: Complete interface for UNIT =ar=
#+begin_src pascal :tangle "~/b/mr/code/ar.pas" :noweb tangle
  {$i xpc.inc}
  unit ar; { Array interface }
  interface
  
    type
      generic IArray<T> = interface
        <<SizeMethods>>
        <<AccessMethods>>
        <<ItemProperty>>
      end;
  
      generic GAbstractArray<T> = class abstract (TInterfacedObject, IArray<T>)
        protected
          _count = cardinal;
          procedure CheckRange( ix : cardinal );
        public
          constructor Create( length : cardinal ); virtual;
          procedure Resize( length : cardinal ); virtual;
          procedure Append( value : t ); virtual;
          property Count : cardinal read _count;
        end;
  
      generic GDynArray<T> = class( GAbstractArray<T> )
        protected
          _array = array of T;
        public
          <<AccessMethods>>
          constructor Create( length : cardinal );
          destructor Destroy;
        end;
  
      generic GFileArray<T> = class( GAbstractArray<T> )
        protected
          _file = file of T;
        public
          <<AccessMethods>>
          constructor Create( var f : file of T );
          destructor Destroy;
        end;
  
      generic GBPlusArray<T> = class( GAbstractArray<T> )
        public
          <<AccessMethods>>
          constructor Create( length : cardinal );
          destructor Destroy;
        end;
  
      generic GEmbeddedArray<T> = class( GAbstractArray<T> )
        public
          <<AccessMethods>>
          constructor Create( a : IArray<T>; length : cardinal );
          destructor Destroy;
        end;
  
  implementation
    <<ar:imp>>
  end.
  
#+end_src
