#+title: mini-rossetta

These are all comparisons of J vs haskell for now.

* running total of first 10 cardinals

#+begin_src j
      +/\>:i.10
  1 3 6 10 15 21 28 36 45 55
#+end_src

#+begin_src haskell
  Prelude> (map sum)[[0..n]|n<-[0..10]
  [1,3,6,10,15,21,28,36,45,55]
#+end_src


* addition table for the numbers ~0 1 2 3~

#+begin_src j
     +/~i.4
  0 1 2 3
  1 2 3 4
  2 3 4 5
  3 4 5 6
#+end_src

#+begin_src haskell
  Prelude> let tbl f xs=[[f x y|x<-xs]|y<-xs]
  Prelude> tbl(+)[0..3]
  [[0,1,2,3],[1,2,3,4],[2,3,4,5],[3,4,5,6]]
#+end_src


* repeat an operation n times

This is just doubling a number 5 times, which is the same as multiplying by 32, but it illustrates the concept:

#+begin_src j
     +~^:5 [ 1  NB. +~ (reflexive addition) is also  +: (double) in j
  32
#+end_src

#+begin_src haskell
  Prelude> let rfx f y = f y y
  Prelude> let pow = (\n f -> if n == 0 then id else f . pow (n-1) f)
  Prelude> pow 5 (rfx (+)) 1
  32
#+end_src

* forks (monadic)

#+begin_src j
    (>: % +:) 2
  0.75
#+end_src

#+begin_src haskell
  Prelude> let mfork f g h y = (f y) `g` (h y)
  Prelude> mfork (1+)(/)(2*) 2
  0.75
#+end_src

* check whether a series is strictly ascending

#+begin_src j
   *./ (}: < }.) i.10    NB. all (behead < curtail) i.10
   1
#+end_src

#+begin_src haskell
  Prelude> all $ (mfork tail (zipWith (<)) init) [0..9]
  True
#+end_src

* hooks (monadic)

Yet another way to double a number:

#+begin_src j
     (+[) 5
  10
#+end_src

#+begin_src haskell
  Prelude> let mhook f g x = f x (g x)
  Prelude> mhook (+) id 5
  10
#+end_src

