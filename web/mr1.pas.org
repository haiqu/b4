#+title: mr1 : reification

* Introduction

Last time around, we created a tiny database file with a single table, or /relation/, and manually populated it, displayed it, and then filtered it by row and column -- all in plain old pascal.

There's nothing inherently wrong with this approach, but it's tedious. One of the main benefits of the relational database model is that it's universal: you use can use one data structure (the relation) for all of your data, so everything works the same way, and you don't have to keep rewriting the same code over and over by hand.

In order to do this, we're going to have to lift the description of a relation's structure up out of the pascal compiler and into a concrete data structure that we can interact with and inspect at runtime. For example, instead of manually printing and justifying each column name, we will use an array of records that map the keys to string labels, display widths, and specific routines for rendering the data.

This process of replacing code with data is called /reification/, and we will come back to it again and again as we transfer more and more of our hand-coded logic into the relational database itself.

We'll start by examining what the pascal compiler already does when we use the =record= keyword to declare a structured data type.

* The Binary Record Format

In [[file:mr0.pas.org][lesson 0]], we defined the =TUrlRec= type:

#+begin_src pascal
type
  TUrlRec = record
              id    : cardinal;
              url   : string[ 36 ];
              title : string[ 24 ];
            end;
#+end_src

We then created a =file of TUrlRec=, and populated it with some records:

#+begin_src pascal
  begin
    Assign( f, 'urldb0.db' );
    ReWrite( f );
    store(   7 , 'http://reddit.com/r/learnprogramming' , 'learn programming' );
    store(   4 , 'http://sourceforge.net/'              , 'SourceForge'       );
    store(   8 , 'http://stackoverflow.com/'            , 'Stack Overflow'    );
    store(   2 , 'https://github.com/'                  , 'GitHub'            );
    store(  13 , 'http://c2.com/cgi/wiki?WikiWikiWeb'   , 'Wiki Wiki Web'     );
    store(   6 , 'http://reddit.com/r/programming'      , 'programming'       );
  end;
#+end_src

Since pascal handled the file for us, we didn't spend much time looking at what it was actually doing. Let address that now, by creating a hex dump of the generated =urldb0.db= file.


** Hex Dump

#+begin_src text
$ hexdump -C urldb0.db
00000000  07 00 00 00 24 68 74 74  70 3a 2f 2f 72 65 64 64  |....$http://redd|
00000010  69 74 2e 63 6f 6d 2f 72  2f 6c 65 61 72 6e 70 72  |it.com/r/learnpr|
00000020  6f 67 72 61 6d 6d 69 6e  67 11 6c 65 61 72 6e 20  |ogramming.learn |
00000030  70 72 6f 67 72 61 6d 6d  69 6e 67 00 00 00 00 00  |programming.....|
00000040  00 00 00 00 04 00 00 00  17 68 74 74 70 3a 2f 2f  |.........http://|
00000050  73 6f 75 72 63 65 66 6f  72 67 65 2e 6e 65 74 2f  |sourceforge.net/|
00000060  72 6e 70 72 6f 67 72 61  6d 6d 69 6e 67 0b 53 6f  |rnprogramming.So|
00000070  75 72 63 65 46 6f 72 67  65 61 6d 6d 69 6e 67 00  |urceForgeamming.|
00000080  00 00 00 00 00 00 00 00  08 00 00 00 19 68 74 74  |.............htt|
00000090  70 3a 2f 2f 73 74 61 63  6b 6f 76 65 72 66 6c 6f  |p://stackoverflo|
000000a0  77 2e 63 6f 6d 2f 70 72  6f 67 72 61 6d 6d 69 6e  |w.com/programmin|
000000b0  67 0e 53 74 61 63 6b 20  4f 76 65 72 66 6c 6f 77  |g.Stack Overflow|
000000c0  69 6e 67 00 00 00 00 00  00 00 00 00 02 00 00 00  |ing.............|
000000d0  13 68 74 74 70 73 3a 2f  2f 67 69 74 68 75 62 2e  |.https://github.|
000000e0  63 6f 6d 2f 77 2e 63 6f  6d 2f 70 72 6f 67 72 61  |com/w.com/progra|
000000f0  6d 6d 69 6e 67 06 47 69  74 48 75 62 4f 76 65 72  |mming.GitHubOver|
00000100  66 6c 6f 77 69 6e 67 00  00 00 00 00 00 00 00 00  |flowing.........|
00000110  0d 00 00 00 22 68 74 74  70 3a 2f 2f 63 32 2e 63  |...."http://c2.c|
00000120  6f 6d 2f 63 67 69 2f 77  69 6b 69 3f 57 69 6b 69  |om/cgi/wiki?Wiki|
00000130  57 69 6b 69 57 65 62 6e  67 0d 57 69 6b 69 20 57  |WikiWebng.Wiki W|
00000140  69 6b 69 20 57 65 62 77  69 6e 67 00 00 00 00 00  |iki Webwing.....|
00000150  00 00 00 00 06 00 00 00  1f 68 74 74 70 3a 2f 2f  |.........http://|
00000160  72 65 64 64 69 74 2e 63  6f 6d 2f 72 2f 70 72 6f  |reddit.com/r/pro|
00000170  67 72 61 6d 6d 69 6e 67  57 65 62 6e 67 0b 70 72  |grammingWebng.pr|
00000180  6f 67 72 61 6d 6d 69 6e  67 65 62 77 69 6e 67 00  |ogrammingebwing.|
00000190  00 00 00 00 00 00 00 00                           |........|
00000198

$ du -b *.db # size in bytes
408     urldb0.db
#+end_src

** Interpretation

Examining the hex dump gives some clues to how the data is laid out in ram.

| column | type       | bytes |
|--------+------------+-------|
| id     | =cardinal=   |     4 |
| url    | =string[36]= |    37 |
| title  | =string[24]= |    25 |
|        | (padding)  |     2 |
|--------+------------+-------|
|        | *total:*     |    68 |
|        | *\times 6 rows*:  |   408 |
#+TBLFM: @7$3=@6$3 * 6::@6$3=vsum(@2$3..@5$3)

It might be a little surprising that a string of 36 1-byte characters takes up 37 bytes, but that's because a =ShortString= uses an extra byte at the stort to record the length. The longest =ShortString= is therefore =string[255]=, which contains 256 bytes: enough room for 255 characters, plus the length byte.

You can see this in action in the hex dump. If you look at the link for the c2 wiki, you'll see how the URL and title fields contain leftover characters 'n' and 'g' from the /r/learnprogramming link. This indicates that the same area in ram was reused each for pass through the loop, and then copied to disk each time. The double-quote character at the start is ascii character number 34 (=$22= in hex). This indicates that the uses 34 of the 36 alloted characters. The extra two characters stick around in ram, but pascal ignores them.

Why the extra 2 bytes at the end? Basically, it's because free pascal is a multi-platform compiler, and on some platforms, loading data that doesn't fall cleanly on word boundaries can have unpleasant consequences. By default, fpc aligns records to a multiple of 4 bytes[fn:1].


* TODO step : manually assign the fields in order
id   = nextInteger
col2 = nextString
col3 = nextInteger

* TODO step : use an array of variants for printing
* TODO step : replace the record with an array of variants
* TODO step : reify the type system
Replace the array of variants an array of bytes.
Field name, type name
** TODO Records are fixed width. replace with arrays of bytes.
** TODO Track the width of the column in bytes.
** TODO The schema is described with arrays of type variables.
You could either load the schema directly from the table's file, or you could have some number of schema tables.
** TODO Define a Database meta-model.
- tables
- column names
- types
* TODO step : replace hand-sequenced parser \rarr array of scanners
** TODO Use the first row to learn the width of the table.

** TODO While not Eof, use =SetLength= to generate each new array.

** TODO Create an Array of parsers.
* TODO Use TClass / RTTI published fields for tool integration.
* TODO Make the separator character configurable.
* TODO Load tables of variants without a particular schema.
* Results

To compile and run the program, use the following commands:

: fpc mr1.pas
: ./urldb1

You should see the following output:

#+begin_example text

#+end_example

* Summary




* Footnotes
[fn:1] /fpc aligns fields to a multiple of 4 bytes/: You can change this behavior with the [[http://www.freepascal.org/docs-html/prog/progsu60.html][$PACKRECORDS directive]]. That page actually claims that the default alignment is 2 bytes, but that doesn't appear to be the case. Hopefully [[http://bugs.freepascal.org/view.php?id=24418][#24418]] in the FPC bug tracker will lead to some clarification soon.
